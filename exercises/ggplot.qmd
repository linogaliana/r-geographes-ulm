---
title: "Produire des repr√©sentations graphiques avec {{< fa brands r-project >}} et `ggplot2`"
echo: true
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=false&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
D√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein √©cran.
</summary>


``` {.yaml code-preview="/slides/ggplot.qmd"}
```

</details>


Dans ce troisi√®me TP,
nous allons apprendre √† cr√©er des repr√©sentations
graphiques synth√©tiques avec {{< fa brands r-project >}} qui est
tr√®s bien outill√© dans le domaine gr√¢ce √† la librairie
`ggplot2`. Cette derni√®re impl√©mente
une [grammaire des graphiques](https://fr.wikibooks.org/wiki/Programmer_en_R/Comprendre_la_grammaire_des_graphiques)
flexible, coh√©rente et simple d'usage. 

Si vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},
une version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/visualisation/matplotlib.html).


::: {.callout-note}

Certains exemples de code pr√©sentent des annotations sur le c√¥t√©,
passez votre souris dessus pour les afficher, comme ci-dessous

```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. Je m'affiche quand on passe la souris sur moi üê≠ !

:::

La pratique de la visualisation se fera, dans ce cours, en r√©pliquant des graphiques qu'on peut trouver sur
la page de l'*open data* de la ville de Paris 
[ici](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name).


Ce TP vise √† initier:

* Principalement au _package_ [`ggplot2`](https://ggplot2.tidyverse.org/) pour la construction de graphiques fig√©s ;
* Au package [`plotly`](https://plotly.com/r/) pour les graphiques 
dynamiques, au format HTML. Nous approfondirons l'apprentissage des
graphiques HTML dans un prochain chapitre en
d√©couvrant [`Observable`](https://observablehq.com/).

Dans ce chapitre, nous allons utiliser les librairies suivantes:

```{r}
#| echo: true
#| output: false
library(scales)
library(readr)
library(dplyr)
library(forcats)
library(lubridate)
library(ggplot2)
library(plotly)
```

Nous verrons par la suite la mani√®re de construire des cartes facilement avec
des formats √©quivalents.

::: {.callout-note}
√ätre capable de construire des visualisations de donn√©es
int√©ressantes est une comp√©tence n√©cessaire √† tout
_data-scientist_ ou chercheur. Pour am√©liorer
la qualit√© de ces visualisations, il est recommand√©
de suivre certains conseils donn√©s par des sp√©cialistes
de la _dataviz_ sur la s√©miologie graphique.

Les bonnes visualisations de donn√©es, comme celles du _New York Times_,
reposent certes sur des outils adapt√©s (des librairies `JavaScript`)
mais aussi sur certaines r√®gles de repr√©sentation qui permettent
de comprendre en quelques secondes le message d'une visualisation.

Ce [post de blog](https://blog.datawrapper.de/text-in-data-visualizations/)
est une ressource qu'il est utile de consulter r√©guli√®rement. 
Ce [post de blog d'Albert Rapp](https://albert-rapp.de/posts/ggplot2-tips/10_recreating_swd_look/10_recreating_swd_look) montre bien comment construire graduellement une bonne visualisation
de donn√©es. 
:::


## Donn√©es

Un sous-ensemble des donn√©es de [Paris _Open Data_](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/information/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name) a √©t√© mis √† disposition
pour faciliter l'import. 
Il s'agit d'une extraction, qui commence √† dater, des donn√©es disponibles
sur le site o√π seules les colonnes
qui servent √† cet exercice ont √©t√© conserv√©es.

Nous proposons
de t√©l√©charger ces donn√©es et les enregistrer dans un fichier sur le disque
dur local avant de l'importer[^1]. Cependant, nous n'allons pas faire
cela manuellement mais nous allons plut√¥t utiliser 
{{< fa brands r-project >}}. Effectuer ce type d'action de mani√®re
manuelle serait une mauvaise pratique du point de vue de la reproductibilit√©.

```{r}
#| echo: true
url <- "https://minio.lab.sspcloud.fr/projet-formation/diffusion/python-datascientist/bike.csv"
download.file(url, "bike.gz") # <1>
```
1. L'extension `.gz` est importante pour la suite car `readr` en a besoin pour comprendre que le fichier est compress√©.

## Premi√®res productions graphiques

Chercher √† produire une visualisation parfaite du premier coup est
illusoire. Il est beaucoup plus r√©aliste d'am√©liorer graduellement 
une repr√©sentation graphique afin, petit √† petit, de mettre en 
avant les effets de structure dans un jeu de donn√©es. 

Nous allons donc commencer par nous repr√©senter la distribution
des passages aux principales stations de mesure.
Pour cela nous allons produire
rapidement un _barplot_ puis l'am√©liorer graduellement. 


Dans cette partie, nous allons ainsi
reproduire les deux premiers graphiques de la
[page d'analyse des donn√©es](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name):
*Les 10 compteurs avec la moyenne horaire la plus √©lev√©e* et *Les 10 compteurs ayant comptabilis√©s le plus de v√©los*. Les valeurs chiffr√©es des graphiques seront diff√©rentes de celles de la page en ligne, c'est normal, nous travaillons sur des donn√©es plus anciennes. 


[^1]: D'habitude, nous recommandons d'utiliser directement l'URL 
de t√©l√©chargement ce qui √©vite de cr√©er un fichier interm√©diaire
sur le disque dur. N√©anmoins, ici, l'import direct avec `readr`
ne fonctionnera pas car le fichier est mal interpr√©t√© par la
librairie. Celle-ci ne comprend pas que le fichier est compress√© car
il lui manque l'extension `.gz` (un format compress√©) √† la fin. 



::: {.callout-tip}
## Exercice 1 : Importer les donn√©es et produire un premier graphique rapidement

Les donn√©es comportent plusieurs dimensions pouvant faire l'objet d'une 
analyse statistique. Il est donc n√©cessaire dans un premier temps
de synth√©tiser celles-ci par des agr√©gations afin d'avoir un
graphique lisible. 

1. Importer les donn√©es de compteurs de v√©los depuis le fichier `bike.gz` ;
2. Garder les dix bornes √† la moyenne la plus √©lev√©e ;

```{r}
#| output: false
df <- readr::read_csv("bike.gz")
```


```{r}
df1 <- df %>%
  group_by(`Nom du compteur`) %>%
  summarise(`Comptage horaire` = mean(`Comptage horaire`, na.rm = TRUE)) %>%
  arrange(desc(`Comptage horaire`)) %>%
  head(10)
```

<details>
<summary>
Les 10 principales stations √† l'issue de la question 2
</summary>
```{r}
head(df1)
```
</details>

On va maintenant pouvoir se concentrer sur la production de la 
repr√©sentation

3. En premier lieu, sans se pr√©occuper des √©l√©ments de style ni de la beaut√©
du graphique, cr√©er la structure du _barplot_ (diagramme en batons) de la
[page d'analyse des donn√©es](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name):

<details>
<summary>
Figure obtenue, sans s'occuper du style
</summary>
```{r}
ggplot(df1, aes(y = `Nom du compteur`, x = `Comptage horaire`)) +
  geom_bar(stat = "identity")
```
</details>

La suite de l'exercice consiste √† am√©liorer graduellement cette repr√©sentation
pour converger vers la reproduction de la version en _open data_. Il
ne s'agit pas encore de se concentrer sur l'esth√©tique de la figure mais
de la rendre intelligible, √† gros trait. 

4. En premier lieu, r√©ordonner les barres sur l'axe des ordonn√©es
gr√¢ce √† la fonction `reorder`. Cela rendra le message de la figure
plus intelligible. 

<details>
<summary>
Figure avec les barres r√©ordonn√©es
</summary>

```{r}
figure1 <- ggplot(df1,
       aes(y = reorder(`Nom du compteur`, `Comptage horaire`), # <1>
           x = `Comptage horaire`)
       ) +
  geom_bar(stat = "identity")
figure1
```
1. On r√©ordonne `Nom du compteur` en fonction de `Comptage horaire`

</details>


5. Modifier votre couche esth√©tique afin
d'appliquer une couleur rouge √† l'ensemble des barres

<details>
<summary>
Figure avec les barres rouges
</summary>

```{r}
figure1 <- ggplot(df1,
       aes(y = reorder(`Nom du compteur`, `Comptage horaire`), # <1>
           x = `Comptage horaire`)
       ) +
  geom_bar(stat = "identity", fill = "red")
figure1
```

</details>

:::

On commence √† avoir quelque chose qui commence √† transmettre
un message synth√©tique sur la nature des donn√©es.
On peut n√©anmoins remarquer plusieurs √©l√©ments probl√©matiques
(par exemple les labels) mais
aussi des √©l√©ments ne correspondant pas (les titres des axes, etc.) ou 
manquants (le nom du graphique...)


::: {.callout-tip}
## Exercice 2 : Un peu de style !

La figure comporte maintenant un message mais il est encore peu
lisible. 

1. Le minimum pour que quelqu'un ne connaissant pas les donn√©es soit
capable de comprendre la repr√©sentation graphique est de labelliser
les axes. Cr√©er les m√™mes labels d'axes que la figure originale. 

<details>
<summary>
Figure avec les axes nomm√©s
</summary>

```{r}
figure1 <- figure1 + labs( # <1>
  title = "Les 10 compteurs avec la moyenne horaire la plus √©lev√©e",
  x = "Nom du compteur",
  y = "Moyenne horaire"
)
figure1
```
1. Il existe de nombreuses mani√®res de proc√©der avec `ggplot` pour labelliser
les axes. Mais la plus simple est la fonction `labs`

</details>


2. Le fond gris permet est certes une marque distinctive que le graphique a √©t√©
produit avec `ggplot2` mais ce n'est pas tr√®s soign√©.
Utiliser un th√®me plus minimaliste afin d'avoir un fond blanc.

<details>
<summary>
Figure avec un fond blanc
</summary>
```{r}
figure1 <- figure1 +
  theme_minimal()
figure1
```

</details>

3. Maintenant, concentrons nous sur les √©l√©ments plus esth√©tiques.
Comme c'est une fonctionnalit√© un peu plus avanc√©e, nous proposons directement
le code pour mettre √† jour votre figure avec les √©l√©ments de style
suivant:

```r
theme(
  axis.text.x = element_text(angle = 45, hjust = 1, color = "red"),
  axis.title.x = element_text(color = "red"),
  plot.title = element_text(hjust = 0.5),
  plot.margin = margin(1, 4, 1, 1, "cm")
)
```

<details>
<summary>
Figure obtenue √† l'issue de ces questions
</summary>
```{r}
figure1 <- figure1 +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = "red"),
    axis.title.x = element_text(color = "red"),
    plot.title = element_text(hjust = 0.5),
    plot.margin = margin(1, 4, 1, 1, "cm")
    )
figure1
```

4. Enfin ajoutons de la complexit√© au graphique avec les chiffres sur
les barres.
En vous aidant de ce [_post_](https://stackoverflow.com/questions/67767859/adding-text-on-each-bar-in-horizontal-bar-plot-in-ggplot), ajouter les comptages horaires moyens comme sur la
figure de l'_open data_ parisien[^annotation]

```{r}
figure1 <- figure1 + 
  geom_text(
    aes(label=round(`Comptage horaire`)),
    position=position_dodge(width=0.9),
    hjust=-0.5
    )
```

[^annotation]: Ce n'est pas forc√©ment une bonne pratique de _dataviz_ de
faire cela. En effet, cela signifie que l'√©chelle et la diversit√©
des donn√©es dans celle-ci ne sont pas directement 
intelligibles. 

</details>

:::

On comprend
ainsi que le boulevard de S√©bastopol est le plus emprunt√©,
ce qui ne vous suprendra pas si vous faites du v√©lo √† Paris. 
N√©anmoins, si vous n'√™tes pas familiers avec la g√©ographie parisienne,
cela sera peu informatif pour vous, vous allez avoir besoin d'une
repr√©sentation graphique suppl√©mentaire: une carte ! Nous verrons
ceci lors d'un prochain chapitre. 

```{r}
#| fig-cap: "Les 10 compteurs avec la moyenne horaire la plus √©lev√©e"
figure1
```

::: {.callout-tip}
## Exercice 3: produire une nouvelle figure

Faire la m√™me chose pour la figure 2 (_"Les 10 compteurs ayant comptabilis√©s le plus de v√©los"_), afin d'obtenir une figure similaire.

<details>

```{r}
df2 <- df %>%
  group_by(`Nom du compteur`) %>%
  summarise(`Comptage horaire` = sum(`Comptage horaire`, na.rm = TRUE)) %>%
  arrange(desc(`Comptage horaire`)) %>%
  head(10)
```

```{r}
# Create a horizontal bar plot
figure2 <- ggplot(df2, aes(y = reorder(`Nom du compteur`, `Comptage horaire`), x = `Comptage horaire`)) +
  geom_bar(stat = "identity", fill = "forestgreen") +
  labs(title = "Les 10 compteurs ayant comptabilis√©s le plus de v√©los",
       x = "Nom du compteur",
       y = "La somme des v√©los comptabilis√©s sur la p√©riode s√©lectionn√©e") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(color = "forestgreen"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<summary>
Figure 2 √† l'issue de cet exercice
</summary>

```{r}
figure2
```

</details>



:::


Les diagrammes en batons (_barplot_) sont extr√™mement communs mais 
qu'ils transmettent. Sur le plan s√©miologique,
les _lollipop charts_ sont pr√©f√©rables: ils
transmettent la m√™me information mais avec moins de bruit
(la largeur des barres du barplot noie un peu l'information).

Voici, par exemple, la deuxi√®me figure de la page, rendue non plus
sous forme de _barplot_ mais sous forme de _lollipop chart_:


```{r}
df2_lollipop <- df2 %>%
  mutate(x =  fct_reorder(`Nom du compteur`, `Comptage horaire` ), y = `Comptage horaire`)

figure2_lollipop <- ggplot(df2_lollipop, aes(x=x, y=y)) +
    geom_segment( aes(xend=x, yend=0), alpha = 0.4) +
    geom_point( size=5, color="forestgreen") +
    coord_flip() +
  labs(title = "Les 10 compteurs ayant comptabilis√©s le plus de v√©los",
       x = "Nom du compteur",
       y = "La somme des v√©los comptabilis√©s sur la p√©riode s√©lectionn√©e") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(color = "forestgreen"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm")) +
  scale_y_continuous(labels = unit_format(unit = "M", scale=1e-6))
```

```{r}
figure2_lollipop
```

<details>
<summary>
Comparaison du _barplot_ et du _lollipop chart_
</summary>
```{r}
#| layout-ncol: 2
#| fig-cap: "Choisissez votre repr√©sentation pr√©f√©r√©e"
#| fig-subcap: 
#|   - "Barplot"
#|   - "Lollipop"
figure2
figure2_lollipop
```
</details>


::: {.callout-tip}
## Exercice 3 bis (optionnel): produire un _lollipop_ chart

Reprendre l'exercice 2 mais √† la place d'un _barplot_, produire
un _lollipop chart_.  
::: 

## Premi√®re agr√©gation temporelle

On va maintenant se concentrer sur la dimension spatiale de notre
jeu de donn√©es √† travers deux approches:

- Un diagramme en barre synth√©tisant l'information de notre jeu de donn√©es
de mani√®re mensuelle ;
- Des s√©ries instructives sur la dynamique temporelle. Cela sera l'objet de la prochaine partie ;


Pour commencer, reproduisons la troisi√®me figure qui est, encore une fois, 
un _barplot_. La premi√®re question implique une premi√®re rencontre avec
une donn√©e temporelle √† travers une op√©ration assez classique en s√©ries
temporelles: changer le format d'une date pour pouvoir faire une agr√©gation
√† un pas de temps plus large. 

::: {.callout-tip}
## Exercice 4: barplot des comptages mensuels

1. Utiliser la fonction `format` pour cr√©er une variable `month`
dont le format respecte, par exemple, le sch√©ma `2019-08` ;
2. Faire la moyenne des comptages horaires pour chaque mois

```{r}
df <- df %>%
  mutate(month = format(`Date et heure de comptage`, "%Y-%m"))
```

```{r}
# Question 2
comptage_horaires_mois <- df %>%
  group_by(month) %>%
  summarise(value = mean(`Comptage horaire`, na.rm = TRUE))
```

<details>
<summary>
Comptages horaires obtenus √† l'issue de cette question
</summary>

```{r}
comptage_horaires_mois
```

</details>

Appliquer les conseils pr√©c√©dents pour construire et am√©liorer
graduellement un graphique afin d'obtenir une figure similaire
√† la 3e production sur la page de l'_open data_ parisien.

```{r}
figure3 <- ggplot(comptage_horaires_mois) +
  geom_bar(aes(x = month, y = value), fill = "#ffcd00", stat = "identity") +
  labs(x = "Date et heure de comptage", y = "Moyenne mensuelle du comptage par heure\nsur la p√©riode s√©lectionn√©e",
       title = "Moyenne mensuelle des comptages v√©los") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.y = element_text(color = "#ffcd00", face = "bold"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<details>
<summary>
Exemple de figure reproduisant l'_open data_ parisien
</summary>

```{r}
figure3
```

</details>

- Question optionnelle: repr√©senter la m√™me information sous forme de _lollipop_

:::


```{r}
figure3
```

Si vous pr√©f√©rez repr√©senter cela sous forme de _lollipop_[^notecouleur]:

```{r}
ggplot(comptage_horaires_mois, aes(x = month, y = value)) +
  geom_segment(aes(xend = month, yend = 0)) +
  geom_point( color="#ffcd00", size=4) +
  labs(x = "Date et heure de comptage", y = "Moyenne mensuelle du comptage par heure\nsur la p√©riode s√©lectionn√©e",
       title = "Moyenne mensuelle des comptages v√©los") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        #axis.title.y = element_text(color = "#ffcd00", face = "bold"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

[^notecouleur]: J'ai retir√© la couleur sur l'axe des ordonn√©es qui, je trouve,
apporte peu √† la figure voire d√©grade la compr√©hension du message. 


## Premi√®re s√©rie temporelle

Il est plus commun de repr√©senter sous forme de s√©rie
les donn√©es ayant une dimension temporelle.


::: {.callout-tip}
## Exercice 5: Repr√©senter une s√©rie temporelle

1. Cr√©er une variable `day` qui transforme l'horodatage en format journalier
du type `2021-05-01`.

```{r}
df <- df %>%
  mutate(day = date(`Date et heure de comptage`))

moyenne_quotidienne <- df %>%
  group_by(day) %>%
  summarise(value = mean(`Comptage horaire`, na.rm = TRUE))
```

2. Repr√©senter sous forme de s√©rie temporelle cette information, sans vous
pr√©occuper du style de la figure.

```{r}
figure4 <- ggplot(moyenne_quotidienne, aes(x = day, y = value)) +
  geom_line(color = "magenta")
```

<details>
<summary>
Figure minimaliste
</summary>
```{r}
figure4
```
</details>

3. Colorer la zone sous la ligne avec la fonction appropri√©e

```{r}
figure4 <- figure4 +
  geom_area(fill="magenta", alpha = 0.6)
```

<details>
<summary>
Figure avec la coloration sous la ligne
</summary>
```{r}
figure4
```
</details>

4. Finaliser le graphique pour reproduire la figure de la page d'_open data_

```{r}
figure4 <- figure4 +
  labs(x = "Date et heure de comptage (Jour)", y = "Moyenne journali√®re du comptage par heure\nsur la p√©riode s√©lectionn√©e",
       title = "Moyenne journali√®re des comptages v√©los") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<details>
<summary>
Figure finalis√©e
</summary>
```{r}
figure4
```
</details>

Voici quelques aides pour cet exercice


<details>
<summary>
üí° Aide pour la question 1
</summary>
Regardez la fonction `day` du _package_ `lubridate`
</details>

<details>
<summary>
üí° Aide pour la question 3
</summary>
[Ce _thread_ sur `stackoverflow`](https://stackoverflow.com/questions/28730083/filling-in-the-area-under-a-line-graph-in-ggplot2-geom-area) peut vous aider.
</details>


<details>
<summary>
Le jeu de donn√©es pour la figure 4
</summary>
```{r}
head(moyenne_quotidienne)
```
</details>

:::

A l'issue de cet exercice, on obtient ainsi une figure prenant la forme
suivante:

```{r}
figure4
```


## Introduction aux graphiques HTML avec `Plotly`

L'inconv√©nient des figures avec `ggplot` est que celles-ci ne permettent
pas d'interaction avec le lecteur. Toute l'information doit donc √™tre
contenue dans la figure ce qui peut la rendre difficile √† lire. 
Si la figure est bien faite, avec diff√©rents niveaux d'information, cela
peut bien fonctionner.

Il est n√©anmoins plus simple, gr√¢ce aux technologies _web_, de proposer des
visualisations √† plusieurs niveaux. Un premier niveau d'information, celui du
coup d'oeil, peut suffire √† assimiler les principaux messages de la
visualisation. Ensuite, un comportement plus volontaire de recherche
d'information secondaire peut permettre d'en savoir plus. Les visualisations
r√©actives, qui sont maintenant la norme dans le monde de la _dataviz_, 
permettent ce type d'approche: le lecteur d'une visualisation peut passer
sa souris √† la recherche d'information compl√©mentaire (par exemple les
valeurs exactes) ou cliquer pour faire appara√Ætre des informations compl√©mentaires
sur la visualisation ou autour.

Ces visualisations reposent sur le m√™me triptyque que l'ensemble de l'√©cosyst√®me
_web_: `HTML`, `CSS` et `JavaScript`. Les utilisateurs de {{< fa brands r-project >}} 
ne vont jamais manipuler directement ces langages, qui demandent une 
certaine expertise, mais vont utiliser des librairies au niveau de {{< fa brands r-project >}} qui g√©n√®reront automatiquement tout le code `HTML`, `CSS` et `JavaScript`
permettant de cr√©er la figure. 

::: {.callout-tip}
## Exercice 6: s√©rie temporelle interactive

1. Cr√©er une figure `Plotly` basique pour repr√©senter
sous forme de s√©rie temporelle la figure 4, sans se pr√©occuper du style

<details>
<summary>
S√©rie temporelle produite sans √©l√©ment de style
</summary>
```{r}
plot_ly(
  moyenne_quotidienne, x = ~day, y = ~value,
  type = 'scatter', mode = 'lines'
)
```
</details>


2. A partir de l'exemple dans la [documentation](https://plotly.com/r/filled-area-plots/),
ajouter une aire sous la figure

<details>
<summary>
Ajout de la couche sous la ligne
</summary>

```{r}
plot_ly(
  moyenne_quotidienne, x = ~day, y = ~value,
  fill = 'tozeroy',
  type = 'scatter', mode = 'lines'
)
```
</details>


3. Jouer sur les √©l√©ments de style pour reproduire la figure 4. Pour profiter
de la r√©activit√© du graphique, soigner l'information obtenue en passant
la souris sur la figure gr√¢ce aux arguments `hovertemplate` et `hoverinfo`

```{r}
fig <- plot_ly(
  moyenne_quotidienne, x = ~day, y = ~value,
  color = I("magenta"),
  hovertemplate = ~paste(day, ": ", round(value), " passages de v√©lo en moyenne par heure"),
  hoverinfo = "text",
  fill = 'tozeroy',
  type = 'scatter', mode = 'lines')
fig4 <- fig %>%
  layout(title = "Moyenne journali√®re des comptages v√©los",
         xaxis = list(title = "Date et heure de comptage (Jour)"),
         yaxis = list(title = "Moyenne journali√®re du comptage par heure\nsur la p√©riode s√©lectionn√©e"))
```


<details>
<summary>
Figure obtenue
</summary>

```{r}
fig4
```

</details>

:::


La version r√©active de la figure est ainsi

```{r}
fig4
```


Cette repr√©sentation montre bien le caract√®re sp√©cial de l'ann√©e 2020. Pour 
rappeller au lecteur distrait la nature particuli√®re de la p√©riode, marqu√©e
par un premier confinement qu'on voit bien dans les donn√©es, on peut,
avec l'aide de la [documentation](https://plotly.com/r/horizontal-vertical-shapes/),
ajouter deux barres verticales pour marquer les dates de d√©but et
de fin de cette p√©riode:


```{r}
#| echo: true
vline <- function(x = 0, color = "royalblue") {
  list(
    type = "line",
    y0 = 0,
    y1 = 1,
    yref = "paper",
    x0 = x,
    x1 = x,
    line = list(color = color, dash="dot")
  )
}

fig4 %>% layout(shapes = list(vline("2020-03-17"), vline("2020-05-11")))
```

Comme dernier exercice, voici comment reproduire cette figure avec 
`Plotly`:

```{r}
df1 <- df1 %>% mutate(`Nom du compteur` = fct_reorder(`Nom du compteur`, `Comptage horaire`))

fig <- plot_ly(
  df1,
  x = ~ `Comptage horaire`, y = ~`Nom du compteur`,
  color = I("red"),
  hovertext = ~paste0(`Nom du compteur`, ": ", round(`Comptage horaire`)),
  hoverinfo = 'text',
  type = 'bar',
  name = 'Principales stations')


fig <- fig %>% layout(
  yaxis = list(title = 'Moyenne horaire'),
  xaxis = list(title = 'Nom du compteur', color = "red")
  )
```


```{r}
fig
```

::: {.callout-tip}
## Exercice 7: un barplot avec `Plotly`

1. Pour avoir imm√©diatement des barres bien ordonn√©es, utiliser la fonction
`fct_reorder` du package `forcats` pour r√©oordonner les valeurs du dataframe
issu de l'exercice 1
2. Utiliser `Plotly` pour cr√©er votre figure.
3. (Optionnel, plus avanc√©) Faire un _lollipop chart_ avec `Plotly`
:::

