---
title: "Produire des cartes avec {{< fa brands r-project >}}"
echo: false
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=true&init.personalInit=«https%3A%2F%2Fraw.githubusercontent.com%2Flinogaliana%2Fr-geographie%2Fmain%2Fsspcloud%2Finit.sh»&networking.user.enabled=true&onyxia.friendlyName=«rstudio-cours-ENS»" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
Dérouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein écran.
</summary>


``` {.yaml code-preview="/slides/ggplot.qmd"}
```

</details>


Dans ce TP,
nous allons apprendre à créer des cartes
avec {{< fa brands r-project >}}. A mesure que {{< fa brands r-project >}}
devient incontournable auprès des personnes manipulant des données
spatiales, les solutions pour produire des cartes 
de qualité deviennent de plus en 
plus nombreuses. {{< fa brands r-project >}} a de moins en moins à envier
aux logiciels spécialisés comme QGIS. 

Si vous êtes intéressés par `Python` {{< fa brands python >}},
une version très proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/visualisation/maps.html).


<!----
La pratique de la cartographie se fera, dans la continuité du chapitre
sur les graphiques, en répliquant des cartes qu'on peut trouver sur
la page de l'*open-data* de la ville de Paris 
[ici](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name).
------>

::: {.callout-note}
Produire de belles cartes demande du temps mais aussi du bon sens. 
Comme toute représentation graphique, il est important de réfléchir au message
à faire passer et aux moyens appropriés.
La sémiologie cartographique, 
une discipline scientifique qui s'intéresse aux messages transmis par les cartes,
propose certaines règles pour éviter de transmettre des messages faussés,
volontairement ou involontairement. 

Certaines peuvent être retrouvées à travers des conseils pratiques
dans
ce [guide de sémiologie cartographique](https://www.insee.fr/fr/statistiques/3640429)
de l'Insee. Celles-ci sont reprises
dans [ce guide](https://juliedjidji.github.io/memocarto/semio.html).

[Cette présentation](https://neocarto.github.io/docs/slides/ENTPE/docs/#/title-slide)
de Nicolas Lambert présente, à partir de nombreux exemples, quelques principes
de la _dataviz_ cartographique.

:::

Ce TP vise à initier:

* Au _package_ [`mapsf`](https://riatelab.github.io/mapsf/),
conçu par les géographiques du RIATE (Paris 7), le _package_ de référence
pour réaliser des cartes avec {{< fa brands r-project >}}
`geoplot` est construit sur `seaborn` et constitue ainsi une extension des graphiques de base.
* Au package [`leaflet`](https://rstudio.github.io/leaflet/) qui est un point d'accès vers la librairie `JavaScript` [leaflet](https://leafletjs.com/) permettant de produire des cartes interactives. Nous approfondirons ultérieurement
les cartes réactives avec un chapitre d'ouverture vers [`Observable`](https://observablehq.com).

Dans ce chapitre, nous allons utiliser les _packages_ suivants:

```{r}
#| output: false
#| echo: true
library(dplyr)
library(sf)
library(stringr)
library(archive)
library(ggplot2)
library(ggmap)
library(glue)
library(ggtext)
library(scales)
library(units)
library(cartiflette)
```

## Données

Au cours de ce chapitre, nous allons utiliser
plusieurs jeux de données pour illustrer
différents types de cartes.

<!-----
* Les comptages de passage de vélos dans les stations de mesure parisiennnes ;
* [La localisation précise des stations](https://parisdata.opendatasoft.com/explore/dataset/comptage-velo-compteurs/download/?format=geojson&timezone=Europe/Berlin&lang=fr)

* Les émissions de gaz à effet de serre estimées au niveau communal par l'`ADEME`. Le jeu de données est
disponible sur [data.gouv](https://www.data.gouv.fr/fr/datasets/inventaire-de-gaz-a-effet-de-serre-territorialise/#_)
et requêtable directement dans {{< fa brands r-project >}} avec
[cet url](https://koumoul.com/s/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/convert) (ce sera l'objet du premier exercice)[^notedownload].
* Idéalement, on utiliserait directement les données
[disponibles sur le site de l'Insee](https://www.insee.fr/fr/statistiques/3560121) mais celles-ci nécessitent un peu de travail
de nettoyage qui n'entre pas dans le cadre de ce TP. 
Pour faciliter l'import de données Insee, il est recommandé d'utiliser les _packages_
[`doremifasol`](https://github.com/InseeFrLab/DoReMIFaSol) et [`insee`](https://github.com/pyr-opendatafr/R-Insee-Data) qui simplifient l'accès aux données
de l'Insee disponibles sur le site web [insee.fr](https://www.insee.fr/fr/accueil)
ou via des API. 
* Les limites officielles administratives des arrondissements et communes de l'agglomération
parisienne. Ce fonds de carte est produit par l'IGN et sa récupération
est facilitée par le _package_ `cartiflette`.
------>


## Import des données

### Données Filosofi

```{r}
#| output: false
#| echo: true
library(doremifasol)
library(tibble)
filosofi <- as_tibble(
  telechargerDonnees("FILOSOFI_COM", date = 2016)
)
head(filosofi)
```

```{r}
#| echo: false
head(filosofi)
```

::: {.callout-note}
La fonction `as_tibble` nous sert à transformer le _dataframe_ de base (`doremifasol` 
ne fait pas d'_a priori_ sur l'écosystème de manipulation adopté) en 
_dataframe_ adapté à une exploitation via le `tidyverse`. 
:::


### Limites communales et départementales

Nous allons utiliser `cartiflette` qui facilite
la récupération des fonds de carte administratifs
de l'IGN.


```{r}
#| eval: false
remotes::install_github("linogaliana/cartiflette-r")
```

En premier lieu, nous allons récupérer les limites 
des départements:

```{r}
#| echo: true
library(cartiflette)
departement_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = "metropole",
    borders="DEPARTEMENT",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

Pour s'en assurer, une carte peut rapidement être
produite:

```{r}
#| echo: true
ggplot(departement_borders) +
  geom_sf(fill = "transparent") +
  theme_void()
```

On va également récupérer les limites des
communes françaises avec `cartiflette`. Pour

```{r}
#| echo: true
commune_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = "metropole",
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

Si on veut s'assurer du caractère fonctionnel du fond de carte
récupéré, on peut représenter les
communes d'un département, par exemple le Finistère:

```{r}
#| echo: true
ggplot(
  commune_borders %>% filter(INSEE_DEP == 29)
  ) +
  geom_sf(fill = "transparent") +
  theme_void()
```

Les exemples de code ci-dessus illustraient une situation
où on ne désire représenter que les limites des polygones
dans l'objet `sf`. C'est une carte utile pour rapidement placer
son jeu de données dans l'espace mais ça n'apporte pas 
d'information supplémentaire. Pour cela, il va être nécessaire
d'utiliser les données tabulaires associées à la dimension spatiale.


::: {.callout-tip}

## Une première carte de la population

L'objectif de cet exercice va être d'enrichir
les informations présentées sur la carte
des départements.

1. Utiliser le code ci-dessous
pour enrichir notre objet `sf` des départements d'une variable
de population:

```{r}
population_dep <- commune_borders %>%
  st_drop_geometry() %>%
  group_by(INSEE_DEP) %>%
  summarise(pop = sum(POPULATION)) %>%
  mutate(pop_4 = cut(pop/1000, breaks = 4))

population_dep <- departement_borders %>% left_join(population_dep)

head(population_dep, 3)
```

2. Adapter le modèle ci-dessous à l'objet `population_dep` pour représenter
une première carte par aplat de couleur ([_choropleth map_](https://en.wikipedia.org/wiki/Choropleth_map)) de la variable `pop`

```{r}
#| output: false
#| echo: true
# Modèle
ggplot(departement_borders) + geom_sf(fill = "white") + theme_void()
```

Cette carte étant peu lisible, on propose, en premier lieu,
de discrétiser ses couleurs.

3. Utiliser la variable `pop_4` pour voir un petit peu à quoi ressemble
une version discrétisée de notre carte de population. 

Cela apparaît mieux mais la discrétisation n'est sans doute pas idéale,
les catégories étant plutôt hasardeuses. Il vaut mieux
utiliser `scale_fill_steps` qui construit de manière plus pertinente les 
catégories de couleurs. 

:::

```{r}
# Question 2
plot_q2_exo1 <- ggplot(population_dep) + geom_sf(aes(fill = pop)) + theme_void()
```

```{r}
# Question 3
plot_q3_exo1 <- ggplot(population_dep) + geom_sf(aes(fill = pop_4)) + theme_void()
```

```{r}
# Question 4
plot_q4_exo1 <- ggplot(
  population_dep
) + geom_sf(aes(fill = pop)) +
  scale_fill_steps() +
  theme_void()
```

```{r}
# Question 5
plot_q5_exo1 <- ggplot(
  population_dep
) + geom_sf(aes(fill = pop)) +
  scale_fill_fermenter(
    n.breaks = 5,
    palette = "RdPu",
    direction = 1,
    labels = label_number(scale_cut = cut_short_scale())
    ) +
  theme_void()
```


```{r}
# Question 6
population_dep <- population_dep %>% st_transform(2154) %>%
  mutate(surface = set_units(st_area(.), "km^2")) %>%
  mutate(density = pop/as.numeric(surface))
```




<details>
<summary>
Carte obtenue à l'exercice 2
</summary>
```{r}
plot_q2_exo1
```
</details>


<details>
<summary>
Carte obtenue à l'exercice 3
</summary>
```{r}
plot_q3_exo1
```
</details>

<details>
<summary>
Carte obtenue à l'exercice 4
</summary>
```{r}
plot_q4_exo1
```
</details>




