---
title: "D√©couverte des objets de base de {{< fa brands r-project >}}"
echo: false
number-sections: true
code-annotations: hover
---

Dans ce premier TP,
nous allons rentrer tranquillement
dans notre parcours de d√©couverte de 
{{< fa brands r-project >}}. 

Cela se fera par les √©tapes suivantes:

1. Familiarisation avec `RStudio`, le logiciel qui nous permettra d'utiliser le langage {{< fa brands r-project >}} ;
2. D√©couverte des objets de base de {{< fa brands r-project >}}: les vecteurs de **nombres**, de **cha√Ænes de caract√®res** et de conditions logiques, les **listes** et les _**dataframes**_ ;
3. D√©couverte de l'**assignation** des objets √† des **variables** pour r√©aliser des op√©rations avec ces derni√®res.

Certains exemples de code pr√©sentent des annotations sur le c√¥t√©,
passez votre souris dessus pour les afficher, comme ci-dessous

```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. Je m'affiche quand on passe la souris sur moi üê≠ !

# Familiarisation avec `RStudio`

Habituellement, pour pouvoir faire du {{< fa brands r-project >}}, on 
utilise le logiciel `RStudio`[^rstudio] qui offre un environnement un peu moins
rudimentaire que l'interface graphique par d√©faut fournie lors de l'installation
de {{< fa brands r-project >}}.

[^rstudio]: Pour installer soi-m√™me `RStudio`, les instructions sont [ici](https://posit.co/download/rstudio-desktop/). N√©anmoins, dans le cadre
de ce cours, vous n'aurez pas besoin de faire l'installation, nous allons
utiliser une infrastructure pr√©configur√©e. De cette mani√®re, nous aurons 
acc√®s au m√™me environnement.

Pour lancer un service `RStudio` sur des serveurs pr√©configur√©s, nous allons
utiliser une infrastructure nomm√©e le [`SSPCloud`](https://datalab.sspcloud.fr/)
qui est d√©velopp√©e par l'√©quipe innovation de l'Insee pour des projets
d'enseignement ou de _data science_.

![](https://git.lab.sspcloud.fr/diit/presentation/energy-data-hack-2022/20220523-day_1-onyxia_onboarding/-/raw/main/slideshow/macbook_onyxia.png){width=50% fig-align="center"}

<br>
Apr√®s avoir cr√©√© un compte sur [datalab.sspcloud.fr/](https://datalab.sspcloud.fr/),
cliquez sur ce bouton :

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=true&init.personalInit=¬´https%3A%2F%2Fraw.githubusercontent.com%2Flinogaliana%2Fr-geographie%2Fmain%2Fsspcloud%2Finit.sh¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

Apr√®s quelques instants de lancement du service sur les serveurs de l'Insee, 
vous pourrez acc√©der √† votre `RStudio` pr√™t √† l'emploi (d√©monstration
en _live_ ou [aide m√©moire](/slides/introduction.html#/prise-en-main-du-ssp-cloud))


:::{.callout-tip collapsable="true"}
## Exercice 1: se familiariser avec `RStudio`

Ce premier exercice vise, apr√®s avoir observ√© la structure des fen√™tres
de `RStudio`, √† prendre en main l'interface:

1. Observer la structure de votre dossier de travail en bas √† droite de `RStudio` ;
2. Cr√©er un script √† partir du menu `File/New File/R script` et l‚Äôenregistrer sous le nom `script1.R` ;
3. Observer la mise √† jour de votre dossier en bas √† droite ;
4. Faire une recherche dans la partie Help de RStudio pour la fonction `list.files` ;
5. Ecrire dans `script1.R` le code qui permet de faire la liste des fichiers de votre dossier de travail ;
6. Utiliser le raccourci `RStudio` <kbd>CTRL</kbd> + <kbd>ENTREE</kbd> pour ex√©cuter ce code dans la console.

::: 



# Les objets uni-dimensionnels

Nous allons commencer par les objets en une dimension, c'est-√†-dire
les listes de valeurs de m√™me type. Par exemple, `["ENS Ulm", "ENS Lyon", "ENS Paris-Saclay"]`
ou `[4 8 15 16 23 42]`. 

Ces listes de valeurs en une dimension peuvent √™tre repr√©sent√©es
par des __vecteurs__. Les quatre types les plus pratiques
en  {{< fa brands r-project >}} sont :

- Les [vecteurs num√©riques](#numeric) ;
- Les [chaines de caract√®res](#characters) ;
- Les [vecteurs logiques](#logical) ;
- Les [facteurs](#factors).

Nous irons ensuite √† des structures de donn√©es plus complexes
mais qui sont en fait celles que nous manipulons plus 
couramment: les [listes](#lists) et les [_dataframes_](#dataframes). 


## Les vecteurs num√©riques (_numeric_) {#numeric}

### Les deux types de vecteurs num√©riques

{{< fa brands r-project >}} propose diff√©rents types d'objets num√©riques. Pour l'analyse de donn√©es, nous allons principalement
nous int√©resser principalement √† deux types :

- les entiers (type `int` pour *integer*)
- les nombres r√©els (type `double` pour nombres √† virgule flottante)

En pratique, les premiers sont un cas sp√©cial des seconds. Contrairement √† d'autres langages,
{{< fa brands r-project >}} ne tente pas de contraindre de mani√®re automatique les nombres sans virgules √† √™tre
des entiers (_integers_). C'est pratique mais sur de gros volumes de donn√©es √ßa peut
poser probl√®me car les _double_ sont plus lourds que les _int_. 


En g√©n√©ral, on utilise la fonction `class` pour afficher le type d'un objet {{< fa brands r-project >}} et
si on veut √™tre plus pr√©cis on peut utiliser `typeof`:

```{r}
#| echo: true
#| output: false
class(3)
typeof(3)
class(3.14)
typeof(3.14)
```

Les fonctions `as.numeric` et `as.integer` peuvent √™tre utilis√©es pour convertir d'un type √† l'autre:

```{r}
#| echo: true
# Conversion en int
as.integer(3.79)
```

::: {.callout-warning}
Attention √† la conversion *double* $\to$ *int*, qui tronque la partie d√©cimale.

```{r}
#| echo: true
# double -> int -> double
as.numeric(
    as.integer(3.79)
)
```
:::

Les _floats_ peuvent √©galement √™tre √©crits en notation scientifique :

```{r}
#| echo: true
2e3
class(2e3)
```


### Op√©rations arithm√©tiques de base

![](img/verybadtrip.gif){fig-align="center"}

Comme tout langage informatique,  {{< fa brands r-project >}} est avant tout
une calculette. On est sauv√©, on peut donc faire des additions:

```{r}
#| echo: true
# Addition
8 + 9
```

::: {.callout-note}
{{< fa brands r-project >}} est bien fait, il adapte le type des variables pour les mettre en coh√©rence lorsqu'elles
peuvent l'√™tre:

```{r}
#| echo: true
# Addition
8.1 + as.integer(9)
```

:::

On a bien-s√ªr acc√®s √† d'autres op√©rations standards:

```{r}
#| echo: true
# Soustraction
5 - 2
# Multiplication
2 * 6
# Division
9 / 4
```

Il faut tout de m√™me faire attention √† la division par 0

```{r}
#| echo: true
# Division par 0
3 / 0
-5 / 0
```

::: {.callout-warning}
Certains langages, comme `Python`, ne permettent pas la division par 0, ils renvoient 
une erreur plut√¥t qu'`Inf`. C'est un peu pi√©geux en `R` car cela peut arriver
d'avoir des divisions par 0 sans qu'on s'en rende compte...
:::

Comme toute calculette, on peut appliquer d'autres types d'op√©rations


```{r}
#| echo: true
#| label: division-euclidienne
# Division euclidienne : quotient
9 %/% 4
# Division euclidienne : reste
9 %% 4
```

```{r}
#| echo: true
# Puissance
2 ^ 5
# Racine carr√©e
sqrt(5)
# Log
log(2)
# Exponentielle
exp(2)
```

L'ordre des op√©rations suit la convention usuelle:

```{r}
#| echo: true
2 + 5 * (10 - 4)
```

### Vectorisation

Si on ne pouvait utiliser {{< fa brands r-project >}}
qu'en mode calculette peu raffin√©e,
√ßa ne serait pas un langage tr√®s int√©ressant pour l'analyse
de donn√©es. L'avantage principal de {{< fa brands r-project >}}
est qu'on va pouvoir
manipuler des vecteurs, c'est √† dire des suites de nombres.
On va consid√©rer que les vecteurs sont des suites de nombres
ordonn√©s en une seule colonne:

$$
\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}
$$

et on va appliquer des op√©rations sur chaque ligne de ces vecteurs. 
On parle de __vectorisation__ des op√©rations pour d√©signer une op√©ration
qui s'appliquera de mani√®re automatique √† chaque √©l√©ment de notre
vecteur.

Par exemple, la multiplication est vectorielle par d√©faut:

```{r}
#| echo: true
5*c(1,20,2)
```

De m√™me l'addition, √† condition de mettre des vecteurs de taille coh√©rente:

```{r}
#| echo: true
c(1,20,2) + c(21,2,20)
c(1,20,2) - 3
```

::: {.callout-warning}
Si la taille des vecteurs n'est pas coh√©rente, {{< fa brands r-project >}}
recycle le vecteur le plus petit jusqu'√† atteindre la bonne taille

```{r}
#| echo: true
c(1,20,2) - c(1,20)
```

:::

## Les cha√Ænes de caract√®res (_characters_) {#characters}

Les cha√Ænes de caract√®res (ou *strings*) sont utilis√©es pour stocker de l'information textuelle.
Plus pr√©cis√©ment, elles peuvent stocker tout caract√®re de type [Unicode](https://fr.wikipedia.org/wiki/Unicode), ce qui inclut les lettres des diff√©rentes langues, mais √©galement la ponctuation, les chiffres, les smileys, etc.


### Cr√©er un _string_

Pour cr√©er une chaine de caract√®res (_string_), on
peut utiliser de mani√®re indiff√©rente les guillemets ou les
apostrophes. 


```{r}
#| echo: true
'mot' # <1>
"√ßa fonctionne aussi" # <2>
```
1. Premi√®re m√©thode: `'`
2. Deuxi√®me m√©thode (pr√©f√©rable): `"`


:::{.callout-warning}
Attention au m√©lange des deux !

```{r}
#| echo: true
#| error: true
print('l'apostrophe, quelle catastrophe')
```

La deuxi√®me apostrophe est comprise comme la fin du _string_,
et {{< fa brands r-project >}} ne sait pas interpr√©ter le reste de la s√©quence.

Il faut donc varier en cas de besoin :

```{r}
#| echo: true
"l'apostrophe, aucun probl√®me" # <1>
```
1. Cette fois, l'apostrophe `'` est bien enchass√©e au sein des guillemets qui
d√©limitent notre _string_.

Cela fonctionne √©galement en sens inverse: les guillements sont bien
interpr√©t√©s lorsqu'ils sont entre apostrophes. 

```{r}
#| echo: true
'les guillemets, "aucun probl√®me"'
```

Comme l'illustre la sortie ci-dessus, il est
possible de bien d√©finir les caract√®res
sp√©ciaux de cette sorte en les √©chappant avec des antislashs `\`:

```{r}
#| echo: true
"les guillemets, \"aucun probl√®me\"" # <1>
'l\'apostrophe, aucun probl√®me' # <1>
```
1. `\` permet √† {{< fa brands r-project >}} de comprendre que l'apostrophe
ou le guillemet fait partie de la chaine de caract√®re et non de sa d√©limitation.

:::

### Quelques fonctions utiles

{{< fa brands r-project >}} propose par d√©faut un certain nombre
de fonctions utiles pour 
extraire ou transformer des vecteurs textuels. On en d√©couvrira
des plus pratiques et plus g√©n√©rales lorsqu'on se focalisera sur
les donn√©es textuelles et le package [`stringr`](https://stringr.tidyverse.org/).

La fonction `nchar` permet de compter le nombre de caract√®res d'un *string*, tous caract√®res inclus (lettres, chiffres, espaces, ponctuation...).

```{r}
#| echo: true
nchar("J'ai 19 charact√®res")
```

Il ne faut pas la confondre avec la fonction `length`. Celle-ci
nous donne la longueur du vecteur. Par exemple, 

```{r}
#| echo: true
length("J'ai 19 charact√®res")
```

est de taille 1 puisqu'on a un seul √©l√©ment dans notre vecteur.
Si on prend un vecteur de plus grande dimension:

```{r}
#| echo: true
length(c("J'ai 19 charact√®res", "pas moi"))
```

On retrouve bien le nombre d'√©l√©ments de notre vecteur en sortie de `length`.

`nchar` est une op√©ration vectorielle, on peut donc compter la longueur
de chaque ligne de notre jeu de donn√©es:

```{r}
#| echo: true
nchar(c("J'ai 19 charact√®res", "pas moi"))
```

L'un des int√©r√™ts des fonctions de base de traitement des donn√©es
textuelles est la possibilit√© de remettre en forme nos cha√Ænes
de caract√®res de mani√®re automatique. Par exemple, l'op√©ration la 
plus simple est de changer la capitalisation de notre texte:

```{r}
#| echo: true
toupper(c("sequence 850", "Sequence 850")) # <1>
tolower(c("SEQuEnce 850", "SEQUENCE 850")) # <2>
```
1. Mettre en majuscules tout le texte.
2. Mettre en minuscules.

Mais on peut aussi nettoyer des chaines textuelles avec quelques fonctions
de base :

```{r}
#| echo: true
strsplit(c("une s√©quence    √† s√©parer", "uneautre√†s√©parer"), split = " ")
```


A ce stade, la sortie obtenue, avec des `[[]]`
peut vous para√Ætre √©trange car nous n'avons pas
encore d√©couvert le type `list`.

Ce type de donn√©es n'√©tant pas forc√©ment pratique
pour l'analyse statistique, pour laquelle on pr√©f√®re des formats
comme le vecteur, ce sera beaucoup plus pratique d'utiliser
le _package_ `stringr` pour faire un _split_.

On peut tout √† fait d√©couper notre _string_ sur autre chose que les espaces!

```{r}
#| echo: true
strsplit(c("une s√©quence    √† s√©parer", "uneautre√†s√©parer"), split = "√†")
```
On peut concat√©ner des chaines de caract√®re ensemble, c'est tr√®s pratique. 
Malheureusement le `+` ne fonctionne pas en `R` pour les chaines de 
caract√®res (contrairement √† `Python`). Pour effectuer cela on 
utilise `paste` ou `paste0` (une version moins g√©n√©rale mais qui est
pens√©e pour les concat√©nations simples):


```{r}
#| echo: true
#| label: paste
paste0(
    "La premi√®re fois qu'Aur√©lien vit B√©r√©nice,",
    " ",
    "il la trouva franchement laide. Elle lui d√©plut, enfin.",
    " ",
    "Il n'aima pas comment elle √©tait habill√©e."
) # <1>

paste(
    "La premi√®re fois qu'Aur√©lien vit B√©r√©nice,",
    "il la trouva franchement laide. Elle lui d√©plut, enfin.",
    "Il n'aima pas comment elle √©tait habill√©e.",
    sep = " "
) # <2>
```

1. Avec `paste0`, on concat√®ne en accolant les _strings_, sans espace.
2. Avec `paste`, on peut choisir la mani√®re d'accoler les _strings_, ici
en mettant des espaces.

On peut utiliser les strings comme _templates_. C'est particuli√®rement
pratique pour automatiquement cr√©er du texte √† partir de valeurs 
issues de nos donn√©es. Pour cela on utilise `sprintf`:

```{r}
#| echo: true
sprintf("La premi√®re fois qu'%s vit %s", "Aur√©lien", "B√©r√©nice")
sprintf("%s et %s font %s", 2, 2, 2+2)
```

`%s` sert √† d√©finir l'endroit o√π sera coll√© le texte voulu. 

## Vecteurs logiques (_logicals_) {#logicals}

En {{< fa brands r-project >}},
les vecteurs logiques sont utilis√©s pour stocker des valeurs bool√©ennes,
c'est-√†-dire des valeurs vraies (`TRUE`) ou fausses (`FALSE`).

Les vecteurs logiques sont couramment utilis√©s pour effectuer des op√©rations de logique, des filtres de donn√©es et des s√©lections conditionnelles. 
Nous y reviendrons par la suite, nous les utiliserons fr√©quemment mais de mani√®re indirecte.


```{r}
#| echo: true
5 > 3  # <1>
2 == 2 # <2> 
0 == (2 - 2) # <3>
1 < 0 # <4>
```
1. `TRUE`, car 5 est sup√©rieur √† 3.
2. `TRUE`, car 2 est √©gal √† 2.
3. `TRUE`, le chainage des op√©rations est respect√©.
4. `FALSE`, car 1 n'est pas inf√©rieur √† 0.

On peut g√©n√©raliser les comparaisons pour obtenir des vecteurs:

```{r}
#| echo: true
c(2, 4, 6, 8, 10, 1, 3) %% 2 == 0
```

On obtient `TRUE` pour les nombres pairs, `FALSE` pour les impairs.

Utiliser des vecteurs logiques nous permettra, au quotidien,
s√©lectionner des donn√©es. Par exemple si on a des donn√©es d'√¢ge, on
peut ne vouloir garder que les pr√©noms des adultes. Cela pourra √™tre fait
sur le mod√®le suivant:

```{r}
#| echo: true
c('Pierre', 'Paul', 'Fran√ßois', 'et les autres')[
    c(25, 3, 61, 17) >= 18
]
```


N√©anmoins nous verrons dans les prochains chapitres
comment int√©grer ce principe dans
une s√©quence plus g√©n√©rale d'op√©rations gr√¢ce au package [`dplyr`](https://dplyr.tidyverse.org/reference/filter.html).


## Les facteurs (_factors_) {#factors}

Les facteurs (_factors_) sont utilis√©s pour repr√©senter
des __variables cat√©gorielles__,
c'est-√†-dire des variables qui prennent un nombre fini et pr√©d√©termin√© de niveaux ou de cat√©gories.

Pour convertir un vecteur num√©rique ou textuel en vecteur, on utilise
la fonction `factor`:

```{r}
#| echo: true
factor(
    c("capitale","pr√©fecture","sous-pr√©fecture","pr√©fecture")
)
factor(c(1,10,3))
```

Les niveaux d'un facteur sont les diff√©rentes cat√©gories
ou valeurs possibles que la variable peut prendre. 
On peut les lister avec la fonction `levels`

```{r}
levels(
    factor(
        c("capitale","pr√©fecture","sous-pr√©fecture","pr√©fecture")
    )
)
```

On peut aussi ordonner ces niveaux si cela a un sens lors de la d√©finition
du facteur. Cela implique n√©anmoins de conna√Ætre, _a priori_ nos diff√©rents 
niveaux et les renseigner √† {{< fa brands r-project >}} dans l'ordre:

```{r}
factor(
    c("capitale","pr√©fecture","sous-pr√©fecture","pr√©fecture"),
    levels = c("capitale","pr√©fecture","sous-pr√©fecture"),
    ordered = TRUE
)
```


# Cr√©er des variables

Jusqu'ici, nous avons d√ª d√©finir √† chaque fois notre objet avant de pouvoir lui appliquer une transformation. Comment faire si l'on veut r√©utiliser un objet et lui appliquer plusieurs transformations ? Ou faire des op√©rations √† partir de diff√©rents objets ?

Pour cela, on va __assigner__ les objets √† des variables.
Cela permet ensuite de r√©aliser des op√©rations √† partir de ces variables.

En {{< fa brands r-project >}},
l'assignation se fait suivant le format :

```r
nom_de_la_variable <- objet
```

Le sens de la fl√®che a une importance et il
est conventionnel de mettre √† gauche le nom
de la variable (et donc
d'utiliser `nom_de_la_variable <- objet` plut√¥t que `objet -> nom_de_la_variable`).

::: {.callout-note}

L'assignation sous la forme `<-` est une sp√©cificit√©
de {{< fa brands r-project >}} par rapport
√† beaucoup de langages. Dans la plupart des langages informatiques,
comme en `Python` par exemple,
l'assignation se fait avec `=`:

```r
nom_de_la_variable = objet
```

C'est √©galement possible en {{< fa brands r-project >}} mais il
est plus conventionnel d'utiliser `<-`.

:::

Voici par exemple comment cr√©er un vecteur `x` :

```{r}
#| echo: true
x <- 5
x
```

Celui-ci peut alors √™tre r√©utilis√© ult√©rieurement dans le code: 

```{r}
#| echo: true
class(x)
```

Les variables peuvent √™tre n'importe quel type d'objet {{< fa brands r-project >}}
et on peut cr√©er une variable √† partir d'une autre:

```{r}
#| echo: true
x <- c(5, 10)
y <- x + 2*x
y
```

::: {.callout-warning}
Contrairement √† d'autres langages de programmation, {{< fa brands r-project >}}
est dit *dynamiquement* typ√© :
il est possible de r√©assigner une variable √† un objet de type diff√©rent. 
Cela facilite la lecture et le d√©veloppement, mais peut parfois g√©n√©rer des probl√®mes difficiles √† d√©bugger...

Il faut donc toujours bien faire attention que le type de la variable est bien celui que l'on s'imagine manipuler.

```{r}
#| echo: true
x <- 3
x <- "blabla"
class(x) #<1>
```
1. `x` n'est plus un _numeric_ mais un _character_. Gare aux op√©rations √† venir sur `x` !
:::

Il y a naturellement certaines contraintes sur les op√©rations selon les types des objets.

```{r}
#| echo: true
#| error: true
x <- "test"
y <- 3
x + y # <1>
```
1. L'addition `+` n'existe pas pour les _strings_ comme on l'a vu pr√©c√©demment

Il est par contre possible d'harmoniser les types en amont :

```{r}
#| echo: true
x <- "5"
y <- 3
z <- as.numeric(x)
y + z
```

# Indexation

En {{< fa brands r-project >}},
les indices de position dans les vecteurs permettent d'acc√©der √† des √©l√©ments sp√©cifiques en utilisant leur position dans le vecteur. 
Les indices commencent √† `1`, ce qui signifie que le premier √©l√©ment a un indice de 1, le deuxi√®me a un indice de 2, et ainsi de suite[^noteindice].

[^noteindice]: 
  Cette remarque peut para√Ætre triviale mais, en informatique, elle ne l'est pas. 
  Beaucoup de langages (`Python`, `C`) ont une indexation qui commence √† 0, comme
  c'est la convention en alg√®bre.
  Cela signifie que le premier √©l√©ment a un indice
  0, le deuxi√®me indice 1 et le dernier un indice $n-1$.

```{r}
#| echo: true
x <- 2*seq(1,10)
```

Pour acc√©der √† un √©l√©ment sp√©cifique du vecteur en utilisant son indice de position, on utilise la notation `[ ]`. 
Par exemple, pour obtenir le deuxi√®me √©l√©ment de `x`, vous pouvez faire ceci :

```{r}
#| echo: true
# Acc√©der au deuxi√®me √©l√©ment du vecteur
deuxieme_position <- x[2]
deuxieme_position
```

Maintenant, la variable `deuxieme_position` contient la valeur 4.

::: {.callout-note}
On peut d'ailleurs mettre √† jour le vecteur `x`, cela ne changera
pas la valeur de la variable `deuxieme_position` :

```{r}
#| echo: true
x <- seq(5,9)
print(deuxieme_position)
deuxieme_position == x[2]
```

En {{< fa brands r-project >}},
une valeur de variable n'est chang√©e que s'il y a,
d'une mani√®re ou d'une autre, r√©assignation. 
:::

On peut aussi utiliser une s√©quence de valeurs pour r√©cup√©rer
un sous-ensemble de notre vecteur (on appelle cette op√©ration _slice_)

```{r}
#| echo: true
x <- seq(5,15)
x[1:5]
x[c(2,3,8)]
```

Il est √©galement possible de faire des s√©lections n√©gatives, c'est-√†-dire
toutes les valeurs sauf certaines. Pour cela, on utilise les indices n√©gatifs

```{r}
#| echo: true
x[-3] # <1>
x[c(-3, -1)] # <2>
```
1. On s√©lectionne toutes les donn√©es sauf le premier √©l√©ment
2. On s√©lectionne toutes les donn√©es sauf les premier et troisi√®me √©l√©ments (l'ordre n'importe pas)

Cependant, ce n'est pas une bonne pratique d'utiliser de mani√®re 
brute les nombres. En effet, imaginons que vous transformiez
dans une longue chaine d'op√©rations votre vecteur: vous ne savez
plus forc√©ment quelles positions stockent quelles valeurs (et sur 
les vrais jeux de donn√©es vous ne savez m√™me pas exactement quelles
lignes de votre jeu de donn√©es stockent quelles valeurs). 

C'est pour cette raison qu'on privil√©gie les s√©lections √† partir de conditions
logiques. On l'avait vu pr√©c√©demment sous cette forme :

```{r}
#| echo: true
c('Pierre', 'Paul', 'Fran√ßois', 'et les autres')[
    c(25, 3, 61, 17) >= 18
]
```

Maintenant que nous connaissons l'assignation de variables interm√©diaires, 
la syntaxe se simplifie, ce qui rend le code plus lisible. 

```{r}
#| echo: true
prenom <- c('Pierre', 'Paul', 'Fran√ßois', 'et les autres')
age <- c(25, 3, 61, 17)
prenom[age >= 18]
```

Un autre exemple pour illustrer avec des donn√©es textuelles:

```{r}
#| echo: true
villes <- c("Paris", "Toulouse", "Narbonne", "Foix")
statut <- c("capitale","pr√©fecture","sous-pr√©fecture","pr√©fecture")
villes[statut == "pr√©fecture"]
```

Nous d√©couvrirons lors du prochain chapitre une g√©n√©ralisation de cette
approche avec les __filtres__ de donn√©es. 

# Les valeurs manquantes

Les vrais jeux de donn√©es ne sont pas toujours complets. Ils le sont
m√™me rarement. Par exemple, 
dans des s√©ries longues de PIB, les valeurs r√©trospectives peuvent
manquer pour des pays qui n'existaient pas avant une certaine date. 

Les valeurs manquantes, souvent repr√©sent√©es
par `NA` (Not Available) en {{< fa brands r-project >}},
sont un aspect essentiel de la gestion des donn√©es et
l'une des forces de {{< fa brands r-project >}}
est de proposer une gestion coh√©rente de celles-ci. Par exemple, si on d√©sire
faire la moyenne mondiale des PIB sur une ann√©e pass√©e: faut-il exclure ou non les
pays pour lesquels on a pas d'information cette ann√©e-l√† ou renvoyer une erreur ?
La gestion appropri√©e des valeurs manquantes est donc
cruciale lors de l'analyse de donn√©es et de la cr√©ation de mod√®les statistiques.

La fonction `is.na()` permet de v√©rifier si une valeur
est manquante dans un vecteur:

```{r}
#| echo: true
donnees <- c(10, NA, 30, NA, 50) # <1>

is.na(donnees) # <2>
```
1. Cr√©er un vecteur avec des valeurs manquantes.
2. Renvoie `TRUE` pour les valeurs manquantes, `FALSE` sinon.

La gestion appropri√©e des valeurs manquantes est cruciale 
pour √©viter des biais dans les analyses statistiques
et pour obtenir des r√©sultats fiables
car les valeurs manquantes sont rarement un hasard: il existe souvent une raison pour lesquelles une valeur est manquante
et l'hypoth√®se de [_missing at random_](https://stefvanbuuren.name/fimd/sec-MCAR.html) est souvent fausse. 

::: {.callout-note collapse="true"}
## Note sur la gestion des valeurs manquantes

Il existe plusieurs approches pour traiter les valeurs manquantes en fonction de l'objectif d'une analyse. Cela d√©passe le cadre de ce cours mais
voici, dans les grandes lignes, les trois strat√©gies les plus courantes sont :

- __Suppression des valeurs manquantes__ : supprimer les lignes contenant des valeurs manquantes √† l'aide de la fonction `na.omit()` ou `complete.cases()`. C'est par exemple ce que fait la r√©gression lin√©aire par d√©faut dans `R`. Cependant, cette approche peut entra√Æner une perte d'informations ou l'introduction de biais, elle n'est donc pas √† faire √† la l√©g√®re ;
- __Imputation des valeurs manquantes__ : En faisant des hypoth√®ses sur la distribution sous-jacente des valeurs manquantes, les valeurs de ces derni√®res peuvent √™tre estim√©es. La m√©thode la plus simple est d'imputer √† la moyenne ou √† la m√©diane mais il existe des m√©thodes moins frustres comme la r√©gression ou les m√©thodes bas√©es sur les voisins les plus proches. N√©anmoins cette imputation n'est pas √† prendre √† la l√©g√®re car elle change la distribution de la variable observ√©e, ce qui peut avoir un
impact sur les analyses ult√©rieures, et elle est tr√®s d√©pendante du choix de mod√©lisation;
- __Traiter les valeurs manquantes comme un groupe √† part__ : Dans les statistiques descriptives, il est possible de r√©aliser des analyses en mettant un groupe o√π les valeurs manquantes sont fr√©quentes √† part.
:::


# Exercices sur les objets uni-dimensionnel

Premi√®re s√©rie d'exercices sur les objets uni-dimensionnels
permettant d'approfondir les notions vues pr√©c√©demment.

<details>
<summary>
Votre √©tat apr√®s cette s√©rie d'exercices ?
</summary>

![](img/exhausted.png){width=70% fig-align="center"}

</details>

:::{.callout-tip}
## Exercice 2

Afficher le type de `x` lorsque : 

```{r}
#| echo: true
x <- 3
x <- "test"
x <- 3.5
```


```{r}
#| output: false
typeof(3)
typeof("test")
typeof(3.5)
```


:::


:::{.callout-tip}
## Exercice 3

Calculer la somme des longueurs de chacune des cha√Ænes de caract√®res suivantes : 

- _"une premi√®re cha√Æne"_
- _"et une deuxi√®me"_
- _"jamais deux sans trois"_

```{r}
#| echo: false
#| output: false
x1 <- "une premi√®re cha√Æne"
x2 <- "et une deuxi√®me"
x3 <- "jamais deux sans trois"
nchar(paste(x1, x2, x3, sep = ""))
```
:::


:::{.callout-tip}
## Exercice 4

Quel est le type adapt√© pour d√©finir un [code commune](https://www.insee.fr/fr/information/6800675) (ne pas chercher
√† importer le jeu de donn√©es[^cognote]) ?

[^cognote]: La suite du cours sera l'occasion d'amplement utiliser ce jeu de donn√©es. 

<details>
<summary>
Aide si vous ne voyez pas o√π est le probl√®me
</summary>
Faire un test sur les premiers d√©partements, par exemple `02350`.
</details>
:::

:::{.callout-tip}
## Exercice 5

Voici une liste de codes communes issus du [Code Officiel G√©ographique (COG)]((https://www.insee.fr/fr/information/6800675))

```{r}
#| echo: true
liste_communes <- c(
  '01363', '02644', '03137', '11311', '12269', '13018', '14458', '15008',
  '23103', '2A119', '2B352', '34005', '2B015', '2A015',
  '38188', '39574', '40223', '41223', '42064',
  '63117', '64218', '65209', '66036', '67515', '68266', 
  '77440', '78372', '79339', '80810', '81295', '82067',
  '93039', '94054', '95061', '97119', '97219', '97356', '97421', '97611'
)
```

1. Extraire le d√©partement (deux premiers caract√®res) pour chaque commune ;
2. Compter le nombre de d√©partements uniques dans nos donn√©es ;

```{r}
#| output: false
# Question 1
dep <- substr(liste_communes, start = 1, stop = 2)
# Question 2
length(
  unique(dep)
)
```

:::


::: {.callout-tip}
## Exercice 6

Supprimer les espaces superflus au d√©but et √† la fin de la cha√Æne suivante :

```{r}
#| echo: true
#| output: false
a <- "    Un string tr√®s mal formatt√©.         "
```

```{r}
trimws(a)
```

<details>
<summary>Aide, si vous √™tes bloqu√©s</summary>
Taper `?trimws()` dans la console pour afficher l'aide de la fonction `trimws()` 
</details>

:::


Les fonctions de base de manipulation de donn√©es textuelles √©tant parfois
un peu difficiles d'usage avec {{< fa brands r-project >}}, on pourra aller beaucoup plus loin 
lorsqu'on d√©couvrira le package `stringr`.


# Les structures plus complexes

## Les matrices

Les __matrices__ peuvent √™tre vues comme le prolongement
en deux dimensions des vecteurs. Au lieu
d'avoir des donn√©es sur une seule dimension, on empile des colonnes c√¥te √† c√¥te.

$$
X = \begin{bmatrix}
x_{11} & x_{12} \\
x_{21} & x_{22} \\
\end{bmatrix}
$$

N√©anmoins, les matrices pr√©sentent une limite fondamentale: on ne peut stocker dans
une matrice que des √©l√©ments de m√™me type. Autrement dit, on aura exclusivement
des matrices num√©riques, des matrices de caract√®res ou des matrices logiques. 
Il est impossible de construire une matrice dont certaines variables sont de type num√©rique (par exemple l‚Äô√¢ge des personnes enqu√™t√©es) et d‚Äôautres de type caract√®re (par exemple leur secteur d‚Äôactivit√©). 

Les matrices ne constituent donc pas un type d‚Äôobjet susceptible de stocker l‚Äôinformation statistique habituellement mobilis√©e dans les enqu√™tes sociales.
Le _mix_ des types n'est pas pratique, c'est pour cette raison que les
praticiens de l'analyse de donn√©es les utilisent peu[^matrices].

[^matrices]: L'objet matrice sera surtout utilis√© par les 
les chercheurs en statistique math√©matique ou les
sp√©cialistes d'algorithmique qui manipuleront des objets num√©riques
bas niveau. 


On propose donc un exercice sur les matrices mais on va rapidement passer
√† des types plus flexibles, plus utiles pour l'analyse de donn√©es o√π les 
variables sont de type diverses. 

:::{.callout-tip}
## Exercice 7

Soit une matrice:

```{r}
#| echo: true
X <- matrix(letters[1:20], nrow = 4, ncol = 5)
```

```{r}
#| output: false
X[1,1] # <1>
X[1,]  # <2>
X[,1]  # <3>
X[2:3,c(1,3)] #<4>
```
1. S√©lectionner l'√©lement le plus √† gauche de notre matrice (premi√®re ligne, premi√®re colonne)
2. S√©lectionner l'ensemble de la premi√®re ligne

3. S√©lectionner l'ensemble de la premi√®re colonne
4. S√©lectionner les √©l√©ments √† l'intersection :
    + Des 2e et 3e ligne
    + Des 1√®res et 3e colonne


<details>
<summary>
Indice si vous √™tes bloqu√©s
</summary>
Avec un vecteur, on acc√©dait aux positions d'un √©l√©ment avec `X[*]`.
Avec les matrices le principe est le m√™me mais on ajoute une dimension `X[*,*]`
</details>
:::


## Les listes

Les __listes__ constituent un type d‚Äôobjet beaucoup plus riche qui permet pr√©cis√©ment de rassembler des types d‚Äôobjets tr√®s diff√©rents : une liste peut contenir tous les types d‚Äôobjet (vecteurs num√©riques, caract√®res, logiques, matrices, etc.), y compris d‚Äôautres listes.

Cette tr√®s grande souplesse fait de la liste l‚Äôobjet de pr√©dilection pour stocker une information complexe et structur√©e, en particulier les r√©sultats de proc√©dures statistiques complexes (r√©gression, classification, etc.).
Pour des donn√©es plus structur√©es, comme le sont les jeux de donn√©es, nous allons voir ensuite que nous
allons utiliser un type sp√©cial de liste: le **_dataframe_**. 

![Proposition d'illustration du principe des listes avec `R` par [Dall-E-2](https://openai.com/dall-e-2)](img/boites.png){width=50% fig-align="center"}

:::{.callout-tip}
## Exercice 8

Voici une liste illustrant le principe de stockage
de donn√©es h√©t√©rog√®nes dans un m√™me objet:

```{r}
ma_liste <- list(
    1,
    "texte",
    matrix(letters[1:20], nrow = 4, ncol = 5),
    c(2, 3, 4)
)
```

1. Afficher la liste et observer la diff√©rence avec l'affichage
des objets pr√©c√©dents
2. Utiliser la notation `[[]]` pour acc√©der au 2e √©l√©ment de notre
liste pour au 2e nombre au sein du dernier √©l√©ment de notre matrice
3. On peut utiliser des noms pour les √©l√©ments de notre liste (c'est
d'ailleurs une bonne pratique). Cr√©er un √©l√©ment nomm√© `communes`
dans votre liste stockant les donn√©es suivantes `c('01363', '02644', '03137', '11311')`
4. Cr√©er un √©l√©ment `departements` en extrayant les deux premiers chiffres
de votre √©l√©ment `communes`

```{r}
#| output: false
#Question 1: afficher la liste
ma_liste
# Question 2: Acc√©der au deuxi√®me √©l√©ment de la liste
ma_liste[[2]]
ma_liste[[4]][2]
# Question 3: mettre √† jour la liste avec un √©l√©ment nomm√© et y acc√©der
ma_liste[['communes']] <- c(
  '01363', '02644', '03137', '11311'
  )
ma_liste[['communes']]  
# Question 4: effectuer une op√©ration 
ma_liste[['departements']] <- substr(ma_liste[['communes']] , start = 1, stop = 2)
```

:::

Lorsqu'on utilise des listes, on peut effectuer
des op√©rations sur chaque √©l√©ment de notre liste.
On appelle cela boucler sur notre liste.

<!----
Les boucles
sont un √©l√©ment fondamental en informatique et `R`
comme tous les autres langages, permet de faire
ce type d'it√©rations (boucles `for`, `while`...).
Cela va √™tre illustr√© dans le prochain exercice. Il
convient n√©anmoins de garder en t√™te que c'est souvent
une mauvaise pratique d'effectuer une boucle: il existe
g√©n√©ralement des op√©rations vectoris√©es d√©velopp√©es
par
des experts qui permettent
d'√©viter de faire soi-m√™me une boucle inefficiente.
----->

:::{.callout-tip}
## Exercice 9

Dans cet exercice, nous allons d√©couvrir comment appliquer la m√™me fonction
aux √©l√©ments de notre liste gr√¢ce √† `lapply`.

1. Avant cela, combien d'√©l√©ments comporte le premier niveau de notre liste ? 
2. Combien d'√©l√©ments comportent chaque niveaux de notre liste ?
3. Cr√©er un vecteur num√©rique qui est √©gal √† 1 si `typeof` de l'√©l√©ment est "double" et 0 sinon 

```{r}
#| output: false
# Question 1
longueur_liste <- length(ma_liste)
# Question 2
lapply(ma_liste, length)
as.numeric(
    lapply(ma_liste, function(l) typeof(l) == "double")
)
```

<details>
<summary>Si `?lapply` ne vous aide pas</summary>
Exemple d'utilisation de `lapply` pour faire la somme dans chaque √©l√©ment de notre
liste

```{r}
#| echo: true
ma_liste_nombres <- list(c(1,2), seq(1,10))
lapply(ma_liste_nombres, sum)
```

</details>

:::


## Les _dataframes_

![Illustration du principe du _dataframe_ (emprunt√©e √† H. Wickham)](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png)

C'est l'objet central de l'analyse de donn√©es avec {{< fa brands r-project >}}. 
Ces objets permettent en effet de repr√©senter sous la forme d‚Äôune table (i.e. d‚Äôun objet √† deux dimensions) des donn√©es de nature tant quantitatives (variables num√©riques) que qualitatives (variables de type caract√®re ou facteur).

Voici par exemple un `dataframe`:

```{r}
#| echo: true
# Cr√©ation du data.frame df
df <- data.frame(
  var1 = 1:10,
  var2 = letters[1:10],
  var3 = rep(c(TRUE, FALSE), times = 5)
)
```

Sa structure interne peut √™tre v√©rifi√©e avec la fonction `str`:

```{r}
#| echo: true
str(df)
```

Quand on travaille avec `R`, l'une des fonctions qu'on utilise le plus est `head`. 
Elle permet d'afficher les $n$ premi√®res lignes de notre jeu de donn√©es:

```{r}
head(df)
```

::: {.callout-warning}
Il est √©galement possible d'utiliser le _viewer_ de `RStudio` pour afficher
des jeux de donn√©es.

Attention cependant, ce _viewer_ peut rencontrer des
probl√®mes de performance et faire planter votre session `R` quand le jeu de
donn√©es commence √† √™tre d'une taille cons√©quente. 

Je recommande plut√¥t
de toucher utiliser `head` ou de s√©lectionner des lignes al√©atoirement avec
`sample`:

```{r}
df[sample(nrow(df), 3), ]
```

:::


Du point de vue de sa structure, un `data.frame` est en r√©alit√© une liste dont tous les √©l√©ments ont la m√™me longueur : c‚Äôest ce qui permet de le repr√©senter sous la forme d‚Äôun tableau √† deux dimensions.

```{r}
#| echo: true
is.list(df)
lapply(df, length)
```

De ce fait, les `data.frame` empruntent leurs caract√©ristiques tant√¥t aux listes,
tant√¥t aux matrices comme le montre l'exercice suivant:

::: {.callout-tip}
## Exercice 10

- V√©rifier la dimension du dataframe `df`
- Compter le nombre de lignes et de colonnes de `df`
- V√©rifier la longueur (_length_) de `df`. Est-ce le comportement d'une
matrice ou d'une liste ? 
- Extraire l'√©lement √† la 2e ligne, 3e colonne de `df`. Est-ce le comportement d'indexation d'une
matrice ou d'une liste ?
- R√©cup√©rer la 3e ligne des variables `var1` et `var2`. 

```{r}
#| output: false
dim(df)
nrow(df)
ncol(df)
length(df) #comme une liste
df[3, c("var1","var2")]
```

:::

L'int√©r√™t d'utiliser un `data.frame` est qu'on peut facilement mettre √† jour
nos donn√©es lors d'une analyse statistique. Les op√©rations les plus classiques,
sur lesquelles nous reviendrons lors du prochain chapitre, sont 

- Cr√©er une nouvelle colonne √† partir des colonnes pr√©-existantes ;
- S√©lectionner un sous-√©chantillon des donn√©es correspondant √† certaines
valeurs observ√©es. 

Il existe plusieurs mani√®res de faire r√©f√©rence √† une colonne d√©j√† existante
d'un dataframe. La plus simple est d'utiliser la structure `dataframe$colonne`. 
Cela nous donnera un vecteur et on retombe sur ce format qu'on conna√Æt d√©j√†:

```{r}
#| echo: true
class(df$var1)
```

::: {.callout-tip}
## Exercice 11

- Cr√©er une colonne `var4` de notre jeu de donn√©es √©gale au carr√© de `var1`
- Cr√©er une colonne `var5` de notre jeu de donn√©es concat√©nant les deux premi√®res
variables en g√©n√©ralisant le sch√©ma `1=a`. 
- Cr√©er un dataframe `df_small1` pour les lignes o√π la condition logique `var3` est v√©rifi√©e
- Cr√©er un dataframe `df_small2` pour les lignes o√π `var1` est paire (voir plus haut l'exemple sur la division euclidienne pour le mod√®le)
:::
