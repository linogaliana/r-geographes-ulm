---
title: "Découverte des objets de base de {{< fa brands r-project >}}"
echo: false
number-sections: true
---

Dans ce premier TP,
nous allons rentrer tranquillement
dans notre parcours de découverte de 
{{< fa brands r-project >}}. 

Cela se fera par les étapes suivantes:

1. Familiarisation avec `RStudio`, le logiciel qui nous permettra d'utiliser le langage {{< fa brands r-project >}} ;
2. Découverte des objets de base de {{< fa brands r-project >}}: les vecteurs de **nombres**, de **chaînes de caractères** et de conditions logiques, les **listes** et les _**dataframes**_ ;
3. Découverte de l'**assignation** des objets à des **variables** pour réaliser des opérations avec ces dernières.

# Familiarisation avec `RStudio`

Habituellement, pour pouvoir faire du {{< fa brands r-project >}}, on 
utilise le logiciel `RStudio`[^rstudio] qui offre un environnement un peu moins
rudimentaire que l'interface graphique par défaut fournie lors de l'installation
de {{< fa brands r-project >}}.

[^rstudio]: Pour installer soi-même `RStudio`, les instructions sont [ici](https://posit.co/download/rstudio-desktop/). Néanmoins, dans le cadre
de ce cours, vous n'aurez pas besoin de faire l'installation, nous allons
utiliser une infrastructure préconfigurée. De cette manière, nous aurons 
accès au même environnement.

Pour lancer un service `RStudio` sur des serveurs préconfigurés, nous allons
utiliser une infrastructure nommée le [`SSPCloud`](https://datalab.sspcloud.fr/)

![](https://git.lab.sspcloud.fr/diit/presentation/energy-data-hack-2022/20220523-day_1-onyxia_onboarding/-/raw/main/slideshow/macbook_onyxia.png){width=50% fig-align="center"}

Après avoir créé un compte sur [datalab.sspcloud.fr/](https://datalab.sspcloud.fr/),
cliqué sur ce bouton 




:::{.callout-tip}
## Exercice 1: se familiariser avec `RStudio`

- Observer la structure de votre dossier de travail en bas à droite de `RStudio`
- Créer un script à partir du menu `File/New File/R script` et l’enregistrer sous le nom `script1.R`
- Observer la mise à jour de votre dossier en bas à droite
- Faire une recherche dans la partie Help de RStudio pour la fonction `list.files`
- Ecrire dans `script1.R` le code qui permet de faire la liste des fichiers de votre dossier de travail
- Utiliser le raccourci `RStudio` <kbd>CTRL</kbd> + <kbd>ENTREE</kbd> pour exécuter ce code dans la console

::: 



# Les objets uni-dimensionnels

Nous allons commencer par les objets en une dimension, c'est-à-dire
les listes de valeurs de même type comme "ENS Ulm", "ENS Lyon", "ENS Paris-Saclay"
ou 4 8 15 16 23 42.

Ces listes de valeurs en une dimension peuvent être représentées
par des vecteurs. Les quatre types les plus pratiques en `R` sont :

- Les vecteurs numériques ;
- Les chaines de caractères ;
- Les vecteurs logiques ;
- Les facteurs.

Nous irons ensuite à des structures de données plus complexes
mais qui sont en fait celles que nous manipulons plus 
couramment: les listes et les _dataframes_. 


## Vecteurs numériques

`R` propose différents types d'objets numériques. Pour l'analyse de données, nous allons principalement
nous intéresser principalement à deux types :

- les entiers (type `int` pour *integer*)
- les nombres réels (type `double` pour nombres à virgule flottante)

En pratique, les premiers sont un cas spécial des seconds. Contrairement à d'autres langages,
`R` ne tente pas de contraindre de manière automatique les nombres sans virgules à être
des entiers (_integers_). C'est pratique mais sur de gros volumes de données ça peut
poser problème car les _double_ sont plus lourds que les _int_. 

En général, on utilise la fonction `class` pour afficher le type d'un objet `R` et
si on veut être plus précis on peut utiliser `typeof`

```{r}
class(3)
typeof(3)
class(3.14)
typeof(3.14)
```

Les fonctions `as.numeric` et `as.integer` peuvent être utilisées pour convertir d'un type à l'autre:

```{r}
# Conversion en int
as.integer(3.79)
```

::: {.callout-danger}
Attention à la conversion *double* -> *int*, qui tronque la partie décimale.

```{r}
# double -> int -> double
as.numeric(
    as.integer(3.79)
)
```
:::

Les floats peuvent également être écrits en notation scientifique :

```{r}
2e3
class(2e3)
```


### Opérations arithmétiques de base

```{r}
# Addition
8 + 9
```

::: {.callout-note}
`R` est bien fait, il adapte le type des variables pour les mettre en cohérence lorsqu'elles
peuvent l'être:

```{r}
# Addition
8.1 + as.integer(9)
```

:::

```{r}
# Soustraction
5 - 2
```

```{r}
# Multiplication
2 * 6
```

```{r}
# Division
9 / 4
```

```{r}
# Division par 0
3 / 0
-5 / 0
```

::: {.callout-note}
Certains langages, comme `Python`, ne permettent pas la division par 0, ils renvoient 
une erreur plutôt qu'`Inf`. C'est un peu piégeux en `R` car cela peut arriver
d'avoir des divisions par 0 sans qu'on s'en rende compte...
:::


```{r}
#| label: division-euclidienne
# Division euclidienne : quotient
9 %/% 4
# Division euclidienne : reste
9 %% 4
```

```{r}
# Puissance
2 ^ 5
# Racine carrée
sqrt(5)
# Log
log(2)
# Exponentielle
exp(2)
```

```{r}
# Ordre des opérations : convention usuelle
2 + 5 * (10 - 4)
```

Si on ne pouvait utiliser `R` qu'en mode calculette de base,
ça ne serait pas un langage très intéressant pour l'analyse
de données. L'avantage principal de `R` est qu'on va pouvoir
manipuler des vecteurs, c'est à dire des suites de nombres.
On va considérer que les vecteurs sont des suites de nombres
ordonnés en une seule colonne:

$$
\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}
$$

et appliquer des opérations sur chaque ligne de ces vecteurs. 
On parle de vectorisation des opérations pour désigner une opération
qui s'appliquera de manière automatique à chaque élément de notre
vecteur.

Par exemple, la multiplication est vectorielle par défaut:

```{r}
5*c(1,20,2)
```

De même l'addition, à condition de mettre des vecteurs de taille cohérente:

```{r}
c(1,20,2) + c(21,2,20)
c(1,20,2) - 3 
```

## Chaînes de caractères

Les chaînes de caractères (ou *strings*) sont utilisées pour stocker de l'information textuelle.
Plus précisément, elles peuvent stocker tout caractère de type [Unicode](https://fr.wikipedia.org/wiki/Unicode), ce qui inclut les lettres des différentes langues, mais également la ponctuation, les chiffres, les smileys, etc.

Un *string* se définit en mettant l'information entre apostrophes ou entre guillemets (anglais). 

### Créer un _string_

```{r}
# Première manière 
'mot'
```

```{r}
# Deuxième manière
"ça fonctionne aussi"
```

:::{.callout-danger}
Attention au mélange des deux !

```{r}
#| error: true
print('l'apostrophe, quelle catastrophe')
```

La seconde apostrophe est comprise comme la fin du _string_, et R ne sait pas interpréter le reste de la séquence.

Il faut donc varier en cas de besoin :

```{r}
"l'apostrophe, aucun problème"
```

Même chose en sens inverse

```{r}
'les guillemets, "aucun problème"'
```


:::

### Quelques fonctions utiles

`R` propose par défaut un certain nombre de fonctions utiles pour 
extraire ou transformer des vecteurs textuels. On en découvrira
des plus pratiques et plus générales lorsqu'on se focalisera sur
les données textuelles et le package [`stringr`](https://stringr.tidyverse.org/)

La fonction `nchar` permet de compter le nombre de caractères d'un *string*, tous caractères inclus (lettres, chiffres, espaces, ponctuation...).

```{r}
nchar("J'ai 19 charactères")
```

Il ne faut pas la confondre avec la fonction `length`. Celle-ci
nous donne la longueur du vecteur. Par exemple, 

```{r}
length("J'ai 19 charactères")
```

est de taille 1 puisqu'on a un seul élément dans notre vecteur. 

```{r}
length(c("J'ai 19 charactères", "pas moi"))
```

D'ailleurs `nchar` est également une opération vectorielle:

```{r}
nchar(c("J'ai 19 charactères", "pas moi"))
```

```{r}
# Mettre en majuscules
toupper(c("sequence 850", "Sequence 850"))
```

```{r}
# Mettre en minuscules
tolower(c("SEQuEnce 850", "SEQUENCE 850"))
```

```{r}
strsplit(c("une séquence    à séparer", "uneautreàséparer"), split = " ")
```

A ce stade, la sortie obtenue peut paraître étrange car nous n'avons pas
encore découvert le type `list`. Ce dernier n'étant pas forcément pratique
pour l'analyse statistique, ce sera beaucoup plus pratique d'utiliser
le _package_ `stringr` pour faire un _split`

```{r}
strsplit(c("une séquence    à séparer", "uneautreàséparer"), split = "à")
```

On peut concaténer des chaines de caractère ensemble, c'est très pratique. 
Malheureusement le `+` ne fonctionne pas en `R` pour les chaines de 
caractères (contrairement à `Python`). Pour effectuer cela on 
utilise `paste` ou `paste0` (une version moins générale mais qui est
pensée pour les concaténations simples):


```{r}
#| label: paste
paste0(
    "La première fois qu'Aurélien vit Bérénice, ",
    "il la trouva franchement laide. Elle lui déplut, enfin. ",
    "Il n'aima pas comment elle était habillée."
)

paste(
    "La première fois qu'Aurélien vit Bérénice,",
    "il la trouva franchement laide. Elle lui déplut, enfin.",
    "Il n'aima pas comment elle était habillée.",
    sep = " "
)
```


On peut utiliser les strings comme _templates_. C'est particulièrement
pratique pour automatiquement créer du texte à partir de valeurs 
issues de nos données. Pour cela on utilise `sprintf`:

```{r}
sprintf("La première fois qu'%s vit %s", "Aurélien", "Bérénice")
sprintf("%s et %s font %s", 2, 2, 2+2)
```

## Vecteurs logiques

En R, les vecteurs logiques sont utilisés pour stocker des valeurs booléennes, c'est-à-dire des valeurs vraies (TRUE) ou fausses (FALSE).
Les vecteurs logiques sont couramment utilisés pour effectuer des opérations de logique, des filtres de données et des sélections conditionnelles. 
Nous y reviendrons par la suite, nous les utiliserons fréquemment mais de manière indirecte.


```{r}
5 > 3  # TRUE, car 5 est supérieur à 3
2 == 2 # TRUE, car 2 est égal à 2
0 == (2 - 2) # TRUE, le chainage des opérations est respecté
1 < 0  # FALSE, car 1 n'est pas inférieur à 0
```

On peut généraliser les comparaisons pour obtenir des vecteurs:

```{r}
c(2, 4, 6, 8, 10, 1, 3) %% 2 == 0 # TRUE pour les nombres pairs, FALSE pour les impairs
```

Ceci nous permettra de sélectionner des données. Par exemple si on a des données d'âge, on
peut ne vouloir garder que les prénoms des adultes. Cela pourra être fait
sur le modèle suivant:

```{r}
c('Pierre', 'Paul', 'François', 'et les autres')[
    c(25, 3, 61, 17) >= 18
]
```


Néanmoins nous verrons comment intégrer ce principe dans
une séquence plus générale d'opérations.


## Les facteurs

Les facteurs (_factors_) sont utilisés pour représenter des variables catégorielles,
c'est-à-dire des variables qui prennent un nombre fini et prédéterminé de niveaux ou de catégories.

Pour convertir un vecteur numérique ou textuel en vecteur, on utilise
la fonction `factor`:

```{r}
factor(
    c("capitale","préfecture","sous-préfecture","préfecture")
)
factor(c(1,10,3))
```

Les niveaux d'un facteur sont les différentes catégories ou valeurs possibles que la variable peut prendre. 
On peut les lister avec la fonction `levels`

```{r}
levels(
    factor(
        c("capitale","préfecture","sous-préfecture","préfecture")
    )
)
```

On peut aussi ordonner les niveaux si cela a un sens:

```{r}
factor(
    c("capitale","préfecture","sous-préfecture","préfecture"),
    levels = c("capitale","préfecture","sous-préfecture"),
    ordered = TRUE
)
```


# Créer des variables

Jusqu'ici, nous avons dû définir à chaque fois notre objet avant de pouvoir lui appliquer une transformation. Comment faire si l'on veut réutiliser un objet et lui appliquer plusieurs transformations ? Ou faire des opérations à partir de différents objets ?

Pour cela, on va assigner les objets à des variables.
Cela permet ensuite de réaliser des opérations à partir de ces variables.

L'assignation se fait suivant le format :

```r
nom_de_la_variable <- objet
```

Le sens de la flèche a une importance et il
est conventionnel de mettre à gauche le nom
de la variable (et donc
d'utiliser `nom_de_la_variable <- objet` plutôt que `objet -> nom_de_la_variable`).

::: {.callout-note}

L'assignation sous la forme `<-` est une spécificité de `R` par rapport
à beaucoup de langages. Dans la plupart des langages informatiques,
comme en `Python` par exemple,
l'assignation se fait avec `=`:

```r
nom_de_la_variable = objet
```

C'est également possible en `R` mais il
est plus conventionnel d'utiliser `<-`.

:::



```{r}
x <- 5
x
```

```{r}
class(x)
```

```{r}
x <- c(5, 10)
```

```{r}
y <- x + 2*x
y
```

Contrairement à d'autres langages de programmation, `R` est dit *dynamiquement* typé : il est possible de réassigner une variable à un objet de type différent. Cela facilite la lecture et le développement, mais peut parfois générer des problèmes difficiles à débugger...
Il faut donc toujours bien faire attention que le type de la variable est bien celui que l'on s'imagine manipuler.

```{r}
x <- 3
x <- "blabla"
class(x)
```

Il y a naturellement certaines contraintes sur les opérations selon les types des objets.

```{r}
#| error: true
x <- "test"
y <- 3
x + y
```

Il est par contre possible d'harmoniser les types en amont :

```{r}
x <- "5"
y <- 3
z <- as.numeric(x)
y + z
```

# Indexation

En `R`, les indices de position dans les vecteurs permettent d'accéder à des éléments spécifiques en utilisant leur position dans le vecteur. 
Les indices commencent à 1, ce qui signifie que le premier élément a un indice de 1, le deuxième a un indice de 2, et ainsi de suite.

```{r}
x <- 2*seq(1,10)
```

Pour accéder à un élément spécifique du vecteur en utilisant son indice de position, on utilise la notation `[ ]`. 
Par exemple, pour obtenir le deuxième élément de `x`, vous pouvez faire ceci :

```{r}
# Accéder au deuxième élément du vecteur
deuxieme_position <- x[2]
deuxieme_position
```

Maintenant, la variable `deuxieme_position` contient la valeur 4.

::: {.callout-note}
On peut d'ailleurs mettre à jour le vecteur `x`, cela ne changera
pas la valeur de la variable `deuxieme_position` :

```{r}
x <- seq(5,9)
print(deuxieme_position)
deuxieme_position == x[2]
```

En `R`, une valeur de variable n'est changée que s'il y a,
d'une manière ou d'une autre, réassignation. 
:::

On peut aussi utiliser une séquence de valeurs pour récupérer
un sous-ensemble de notre vecteur (on appelle cette opération _slice_)

```{r}
x <- seq(5,15)
x[1:5]
x[c(2,3,8)]
```

Il est également possible de faire des sélections négatives, c'est-à-dire
toutes les valeurs sauf certaines. Pour cela, on utilise les indices négatifs

```{r}
x[-3]
x[c(-3, -1)]
```

Cependant, ce n'est pas une bonne pratique d'utiliser de manière 
brute les nombres. En effet, imaginons que vous transformiez
dans une longue chaine d'opérations votre vecteur: vous ne savez
plus forcément quelles positions stockent quelles valeurs (et sur 
les vrais jeux de données vous ne savez même pas exactement quelles
lignes de votre jeu de données stockent quelles valeurs). 

C'est pour cette raison qu'on privilégie les sélections à partir de conditions
logiques. On l'avait vu précédemment sous cette forme :

```{r}
c('Pierre', 'Paul', 'François', 'et les autres')[
    c(25, 3, 61, 17) >= 18
]
```

Maintenant que nous connaissons l'assignation de variables intermédiaires, 
la syntaxe se simplifie.

```{r}
villes <- c("Paris", "Toulouse", "Narbonne", "Foix")
statut <- c("capitale","préfecture","sous-préfecture","préfecture")
villes[statut == "préfecture"]
```

Nous découvrirons lors du prochain chapitre une généralisation de cette
approche avec les __filtres__ de données. 

# Les valeurs manquantes

Les vrais jeux de données ne sont pas toujours complets et le sont
même rarement. Par exemple, 
dans des séries longues de PIB, les valeurs rétrospectives peuvent
manquer pour des pays qui n'existaient pas avant une certaine date. 

Les valeurs manquantes, souvent représentées par `NA` (Not Available) en `R`,
sont un aspect essentiel de la gestion des données et l'une des forces de `R`
est de proposer une gestion cohérente de celles-ci. Par exemple, si on désire
faire la moyenne mondiale des PIB sur une année passée: faut-il exclure ou non les
pays pour lesquels on a pas d'information cette année-là ou renvoyer une erreur ?
La gestion appropriée des valeurs manquantes est cruciale lors de l'analyse de données et de la création de modèles statistiques.

La fonction `is.na()` permet de vérifier si une valeur est manquante dans un vecteur:

```{r}
# Créer un vecteur avec des valeurs manquantes
donnees <- c(10, NA, 30, NA, 50)

is.na(donnees) # Renvoie TRUE pour les valeurs manquantes, FALSE sinon
```

La gestion appropriée des valeurs manquantes est cruciale pour éviter des biais dans les analyses statistiques et pour obtenir des résultats fiables
car les valeurs manquantes sont rarement un hasard: il existe souvent une raison pour lesquelles une valeur est manquante
et l'hypothèse de [_missing at randomn_](https://stefvanbuuren.name/fimd/sec-MCAR.html) est souvent fausse. 

Il existe plusieurs approches pour traiter les valeurs manquantes en fonction de l'objectif d'une analyse. Les trois stratégies les plus courantes sont :

- Suppression des valeurs manquantes : supprimer les lignes contenant des valeurs manquantes à l'aide de la fonction `na.omit()` ou `complete.cases()` (c'est par exemple ce que fait la régression linéaire par défaut dans `R`). Cependant, cette approche peut entraîner une perte d'informations et l'introduction de biais, elle n'est donc pas à faire à la légère.
- Imputation des valeurs manquantes : En faisant des hypothèses sur la distribution sous-jacente des valeurs manquantes, les valeurs de ces dernières peuvent être estimées. La méthode la plus simple est d'imputer à la moyenne ou à la médiane mais il existe des méthodes moins frustres comme la régression ou les méthodes basées sur les voisins les plus proches. Néanmoins cette imputation n'est pas à prendre à la légère car elle change la distribution de la variable observée, ce qui peut avoir un
impact sur les analyses ultérieures, et elle est très dépendante du choix de modélisation. 
- Traiter les valeurs manquantes comme un groupe à part : Dans les statistiques descriptives, il est possible de réaliser des analyses en mettant un groupe où les valeurs manquantes sont fréquentes à part.


# Exercices

:::{.callout-exercice}
## Exercice 2
Afficher le type de `x` lorsque : 

```{r}
#| output: false
x <- 3
x <- "test"
x <- 3.5
```
:::


:::{.callout-exercice}
## Exercice 3

Calculer la somme des longueurs de chacune des chaînes de caractères suivantes : 

- "une première chaîne"
- "et une deuxième"
- "jamais deux sans trois"

```{r}
#| echo: false
#| output: false

x1 <- "une première chaîne"
x2 <- "et une deuxième"
x3 <- "jamais deux sans trois"
nchar(paste(x1, x2, x3, sep = ""))
```
:::


:::{.callout-exercice}
## Exercice 4

Quel est le type adapté pour définir un [code commune](https://www.insee.fr/fr/information/6800675) ?

<details>
<summary>
Aide si vous ne voyez pas où est le problème
</summary>
Faire un test sur les premiers départements, par exemple 02350.
</details>
:::

:::{.callout-exercice}
## Exercice 5

Voici une liste de codes communes issus du COG

```{r}
#| echo: true
liste_communes <- c(
  '01363', '02644', '03137', '11311', '12269', '13018', '14458', '15008',
  '23103', '2A119', '2B352', '34005', '2B015', '2A015',
  '38188', '39574', '40223', '41223', '42064',
  '63117', '64218', '65209', '66036', '67515', '68266', 
  '77440', '78372', '79339', '80810', '81295', '82067',
  '93039', '94054', '95061', '97119', '97219', '97356', '97421', '97611'
)
```

1. Extraire le département (deux premiers caractères) pour chaque commune
2. Compter le nombre de départements uniques dans nos données

```{r}
#| output: false
# Question 1
dep <- substr(liste_communes, start = 1, stop = 2)
# Question 2
length(
  unique(dep)
)
```

:::


:::{.callout-exercice}
## Exercice 6
Supprimer les espaces superflus au début et à la fin de la chaîne suivante :

<details>
<summary>Aide, si vous êtes bloqués</summary>
Taper `?trimws()` dans la console pour afficher l'aide de la fonction `trimws()` 
</details>

```{r}
a <- "    Un string très mal formatté.         "
trimws(a)
```
:::



Les fonctions de base de manipulation de données textuelles étant parfois
un peu difficiles d'usage avec `R`, on pourra aller beaucoup plus loin 
lorsqu'on découvrira le package `stringr`.


# Les structures plus complexes

Le prolongement naturel des vecteurs sont les matrices. 

Les matrices peuvent être vues comme le prolongement en deux dimensions des vecteurs : au lieu
d'avoir des données sur une seule dimension, on empile des colonnes côte à côte.

$$
X = \begin{bmatrix}
x_{11} & x_{12} \\
x_{21} & x_{22} \\
\end{bmatrix}
$$

Néanmoins, les matrices présentent une limite fondamentale: on ne peut stocker dans
une matrice que des éléments de même type. Autrement dit, on aura exclusivement
des matrices numériques, des matrices de caractères ou des matrices logiques. 
Il est impossible de construire une matrice dont certaines variables sont de type numérique (par exemple l’âge des personnes enquêtées) et d’autres de type caractère (par exemple leur secteur d’activité). Les matrices ne constituent donc pas un type d’objet susceptible de stocker l’information statistique habituellement mobilisée dans les enquêtes sociales.
Le
_mix_ des types n'est pas pratique, c'est pour cette raison qu'en fait on utilise
peu les matrices (sauf si on fait de la statistique mathématique ou de l'algorithmique). 


On propose donc un exercice sur les matrices mais on va rapidement passer
à des types plus flexibles, plus utiles pour l'analyse de données où les 
variables sont de type diverses. 

:::{.callout-exercice}
## Exercice 7
X <- matrix(letters[1:20], nrow = 4, ncol = 5)

1. Sélectionner l'élement le plus à gauche de notre matrice (première ligne, première colonne)
2. Sélectionner l'ensemble de la première ligne
3. Sélectionner l'ensemble de la première colonne
4. Sélectionner les éléments à l'intersection :
    + Des 2e et 3e ligne
    + Des 1ères et 3e colonne

<details>
<summary>
Indice si vous êtes bloqués
</summary>
Avec un vecteur, on accédait aux positions d'un élément avec `x[*]`.
Avec les matrices le principe est le même mais on ajoute une dimension `x[*,*]`
</details>
:::


## Listes

Les listes constituent un type d’objet beaucoup plus riche qui permet précisément de rassembler des types d’objets très différents : une liste peut contenir tous les types d’objet (vecteurs numériques, caractères, logiques, matrices, etc.), y compris d’autres listes.

Cette très grande souplesse fait de la liste l’objet de prédilection pour stocker une information complexe et structurée, en particulier les résultats de procédures statistiques complexes (régression, classification, etc.).
Pour des données plus structurées, comme le sont les jeux de données, nous allons voir ensuite que nous
allons utiliser un type spécial de liste: le _dataframe_. 

:::{.callout-exercice}
## Exercice 8

Voici une liste illustrant le principe de stockage
de données hétérogènes dans un même objet:

```{r}
ma_liste <- list(
    1,
    "texte",
    matrix(letters[1:20], nrow = 4, ncol = 5),
    c(2, 3, 4)
)
```

1. Afficher la liste et observer la différence avec l'affichage
des objets précédents
2. Utiliser la notation `[[]]` pour accéder au 2e élément de notre
liste pour au 2e nombre au sein du dernier élément de notre matrice
3. On peut utiliser des noms pour les éléments de notre liste (c'est
d'ailleurs une bonne pratique). Créer un élément nommé `communes`
dans votre liste stockant les données suivantes `c('01363', '02644', '03137', '11311')`
4. Créer un élément `departements` en extrayant les deux premiers chiffres
de votre élément `communes`

```{r}
# Question 1: afficher la liste
ma_liste
# Question 2: Accéder au deuxième élément de la liste
ma_liste[[2]]
ma_liste[[4]][2]
# Question 3: mettre à jour la liste avec un élément nommé et y accéder
ma_liste[['communes']] <- c(
  '01363', '02644', '03137', '11311'
  )
ma_liste[['communes']]  
# Question 4: effectuer une opération 
ma_liste[['departements']] <- substr(ma_liste[['communes']] , start = 1, stop = 2)
```
:::

Lorsqu'on utilise des listes, on peut effectuer
des opérations sur chaque élément de notre liste.
On appelle cela boucler sur notre liste.

<!----
Les boucles
sont un élément fondamental en informatique et `R`
comme tous les autres langages, permet de faire
ce type d'itérations (boucles `for`, `while`...).
Cela va être illustré dans le prochain exercice. Il
convient néanmoins de garder en tête que c'est souvent
une mauvaise pratique d'effectuer une boucle: il existe
généralement des opérations vectorisées développées
par
des experts qui permettent
d'éviter de faire soi-même une boucle inefficiente.
----->

:::{.callout-exercice}
## Exercice 9

1. Combien d'éléments comporte le premier niveau de notre liste ? 
2. Combien d'éléments comportent chaque niveaux de notre liste ?
3. Créer un vecteur numérique qui est égal à 1 si `typeof` de l'élément est "double" et 0 sinon 

```{r}
longueur_liste <- length(ma_liste)
lapply(ma_liste, length)
for (i in seq_along(ma_liste)) length(ma_liste[[i]])
as.numeric(
    lapply(ma_liste, function(l) typeof(l) == "double")
)
```



:::


## Dataframes