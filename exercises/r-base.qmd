 

Dans ce premier TP, nous allons découvrir les objets les plus fondamentaux en R : les **nombres** et les **chaînes de caractères**.

Nous allons également voir comment on peut assigner des objets à des **variables** pour réaliser des opérations avec ces objets.

Avant cela, un exercice préparatoire pour se familiariser avec `R` et `RStudio`:

:::{.callout-exercice}
## Exercice 1

- Observer la structure de votre dossier de travail en bas à droite de `RStudio`
- Créer un script à partir du menu `File/New File/R script` et l’enregistrer sous le nom `script1.R`
- Observer la mise à jour de votre dossier en bas à droite
- Faire une recherche dans la partie Help de RStudio pour la fonction `list.files`
- Ecrire dans `script1.R` le code qui permet de faire la liste des fichiers de votre dossier de travail
- Utiliser le raccourci `RStudio` <kbd>CTRL</kbd> + <kbd>ENTREE</kbd> pour exécuter ce code dans la console

::: 

# Principaux types d'objets en `R`

Nous allons commencer par les objets en une dimension, c'est-à-dire
les listes de valeurs de même type comme "ENS Ulm", "ENS Lyon", "ENS Paris-Saclay"
ou 4 8 15 16 23 42.

Ces listes de valeurs en une dimension peuvent être représentées
par des vecteurs. Les quatre types les plus pratiques en `R` sont :

- Les vecteurs numériques ;
- Les chaines de caractères ;
- Les vecteurs logiques ;
- Les facteurs.


## Vecteurs numériques

`R` propose différents types d'objets numériques. Pour l'analyse de données, nous allons principalement
nous intéresser principalement à deux types :

- les entiers (type `int` pour *integer*)
- les nombres réels (type `double` pour nombres à virgule flottante)

En pratique, les premiers sont un cas spécial des seconds. Contrairement à d'autres langages,
`R` ne tente pas de contraindre de manière automatique les nombres sans virgules à être
des entiers (_integers_). C'est pratique mais sur de gros volumes de données ça peut
poser problème car les _double_ sont plus lourds que les _int_. 

En général, on utilise la fonction `class` pour afficher le type d'un objet `R` et
si on veut être plus précis on peut utiliser `typeof`

```{r}
class(3)
typeof(3)
class(3.14)
typeof(3.14)
```

Les fonctions `as.numeric` et `as.integer` peuvent être utilisées pour convertir d'un type à l'autre:

```{r}
# Conversion en int
as.integer(3.79)
```

::: {.callout-danger}
Attention à la conversion *double* -> *int*, qui tronque la partie décimale.

```{r}
# double -> int -> double
as.numeric(
    as.integer(3.79)
)
```
:::

Les floats peuvent également être écrits en notation scientifique :

```{r}
2e3
class(2e3)
```


### Opérations arithmétiques de base

```{r}
# Addition
8 + 9
```

::: {.callout-note}
`R` est bien fait, il adapte le type des variables pour les mettre en cohérence lorsqu'elles
peuvent l'être:

```{r}
# Addition
8.1 + as.integer(9)
```

:::

```{r}
# Soustraction
5 - 2
```

```{r}
# Multiplication
2 * 6
```

```{python}
# Division
9 / 4
```

```{python}
# Division par 0
3 / 0
-5 / 0
```

::: {.callout-note}
Certains langages, comme `Python`, ne permettent pas la division par 0, ils renvoient 
une erreur plutôt qu'`Inf`. C'est un peu piégeux en `R` car cela peut arriver
d'avoir des divisions par 0 sans qu'on s'en rende compte...
:::


```{r}
# Division euclidienne : quotient
9 %/% 4
# Division euclidienne : reste
9 %% 4
```

```{r}
# Puissance
2 ^ 5
# Racine carrée
sqrt(5)
# Log
log(2)
# Exponentielle
exp(2)
```

```{r}
# Ordre des opérations : convention usuelle
2 + 5 * (10 - 4)
```

Si on ne pouvait utiliser `R` qu'en mode calculette de base,
ça ne serait pas un langage très intéressant pour l'analyse
de données. L'avantage principal de `R` est qu'on va pouvoir
manipuler des vecteurs, c'est à dire des suites de nombres.
On va considérer que les vecteurs sont des suites de nombres
ordonnés en une seule colonne:

$$
\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}
$$

et appliquer des opérations sur chaque ligne de ces vecteurs. 
On parle de vectorisation des opérations pour désigner une opération
qui s'appliquera de manière automatique à chaque élément de notre
vecteur.

Par exemple, la multiplication est vectorielle par défaut:

```{r}
5*c(1,20,2)
```

De même l'addition, à condition de mettre des vecteurs de taille cohérente:

```{r}
c(1,20,2) + c(21,2,20)
c(1,20,2) - 3 
```

## Chaînes de caractères

Les chaînes de caractères (ou *strings*) sont utilisées pour stocker de l'information textuelle.
Plus précisément, elles peuvent stocker tout caractère de type [Unicode](https://fr.wikipedia.org/wiki/Unicode), ce qui inclut les lettres des différentes langues, mais également la ponctuation, les chiffres, les smileys, etc.

Un *string* se définit en mettant l'information entre apostrophes ou entre guillemets (anglais). 

### Créer un _string_

```{r}
# Première manière 
'mot'
```

```{r}
# Deuxième manière
"ça fonctionne aussi"
```

:::{.callout-danger}
Attention au mélange des deux !

```{r}
#| error: true
print('l'apostrophe, quelle catastrophe')
```

La seconde apostrophe est comprise comme la fin du _string_, et R ne sait pas interpréter le reste de la séquence.

Il faut donc varier en cas de besoin :

```{r}
"l'apostrophe, aucun problème"
```

Même chose en sens inverse

```{r}
'les guillemets, "aucun problème"'
```


:::

### Quelques fonctions utiles

`R` propose par défaut un certain nombre de fonctions utiles pour 
extraire ou transformer des vecteurs textuels. On en découvrira
des plus pratiques et plus générales lorsqu'on se focalisera sur
les données textuelles et le package [`stringr`](https://stringr.tidyverse.org/)

La fonction `nchar` permet de compter le nombre de caractères d'un *string*, tous caractères inclus (lettres, chiffres, espaces, ponctuation...).

```{r}
nchar("J'ai 19 charactères")
```

Il ne faut pas la confondre avec la fonction `length`. Celle-ci
nous donne la longueur du vecteur. Par exemple, 

```{r}
length("J'ai 19 charactères")
```

est de taille 1 puisqu'on a un seul élément dans notre vecteur. 

```{r}
length(c("J'ai 19 charactères", "pas moi"))
```

D'ailleurs `nchar` est également une opération vectorielle:

```{r}
nchar(c("J'ai 19 charactères", "pas moi"))
```

```{r}
# Mettre en majuscules
toupper(c("sequence 850", "Sequence 850"))
```

```{r}
# Mettre en minuscules
tolower(c("SEQuEnce 850", "SEQUENCE 850"))
```

```{r}
strsplit(c("une séquence    à séparer", "uneautreàséparer"), split = " ")
```

A ce stade, la sortie obtenue peut paraître étrange car nous n'avons pas
encore découvert le type `list`. Ce dernier n'étant pas forcément pratique
pour l'analyse statistique, ce sera beaucoup plus pratique d'utiliser
le _package_ `stringr` pour faire un _split`

```{r}
strsplit(c("une séquence    à séparer", "uneautreàséparer"), split = "à")
```

On peut concaténer des chaines de caractère ensemble, c'est très pratique. 
Malheureusement le `+` ne fonctionne pas en `R` pour les chaines de 
caractères (contrairement à `Python`). Pour effectuer cela on 
utilise `paste` ou `paste0` (une version moins générale mais qui est
pensée pour les concaténations simples):


```{r}
paste0(
    "La première fois qu'Aurélien vit Bérénice, ",
    "il la trouva franchement laide. Elle lui déplut, enfin. ",
    "Il n'aima pas comment elle était habillée."
)

paste(
    "La première fois qu'Aurélien vit Bérénice,",
    "il la trouva franchement laide. Elle lui déplut, enfin.",
    "Il n'aima pas comment elle était habillée.",
    sep = " "
)
```


On peut utiliser les strings comme _templates_. C'est particulièrement
pratique pour automatiquement créer du texte à partir de valeurs 
issues de nos données. Pour cela on utilise `sprintf`:

```{r}
sprintf("La première fois qu'%s vit %s", "Aurélien", "Bérénice")
sprintf("%s et %s font %s", 2, 2, 2+2)
```

## Vecteurs logiques

En R, les vecteurs logiques sont utilisés pour stocker des valeurs booléennes, c'est-à-dire des valeurs vraies (TRUE) ou fausses (FALSE).
Les vecteurs logiques sont couramment utilisés pour effectuer des opérations de logique, des filtres de données et des sélections conditionnelles. 
Nous y reviendrons par la suite, nous les utiliserons fréquemment mais de manière indirecte.


```{r}
5 > 3  # TRUE, car 5 est supérieur à 3
2 == 2 # TRUE, car 2 est égal à 2
0 == (2 - 2) # TRUE, le chainage des opérations est respecté
1 < 0  # FALSE, car 1 n'est pas inférieur à 0
```

On peut généraliser les comparaisons pour obtenir des vecteurs:

```{r}
c(2, 4, 6, 8, 10, 1, 3) %% 2 == 0 # TRUE pour les nombres pairs, FALSE pour les impairs
```

Ceci nous permettra de sélectionner des données. Par exemple si on a des données d'âge, on
peut ne vouloir garder que les prénoms des adultes. Cela pourra être fait
sur le modèle suivant:

```{r}
c('Pierre', 'Paul', 'François', 'et les autres')[
    c(25, 3, 61, 17) >= 18
]
```


Néanmoins nous verrons comment intégrer ce principe dans
une séquence plus générale d'opérations.


## Les facteurs

Les facteurs (_factors_) sont utilisés pour représenter des variables catégorielles,
c'est-à-dire des variables qui prennent un nombre fini et prédéterminé de niveaux ou de catégories.

Pour convertir un vecteur numérique ou textuel en vecteur, on utilise
la fonction `factor`:

```{r}
factor(
    c("capitale","préfecture","sous-préfecture","préfecture")
)
factor(c(1,10,3))
```

Les niveaux d'un facteur sont les différentes catégories ou valeurs possibles que la variable peut prendre. 
On peut les lister avec la fonction `levels`

```{r}
levels(
    factor(
        c("capitale","préfecture","sous-préfecture","préfecture")
    )
)
```

On peut aussi ordonner les niveaux si cela a un sens:

```{r}
factor(
    c("capitale","préfecture","sous-préfecture","préfecture"),
    levels = c("capitale","préfecture","sous-préfecture"),
    ordered = TRUE
)
```


# Créer des variables

Jusqu'ici, nous avons dû définir à chaque fois notre objet avant de pouvoir lui appliquer une transformation. Comment faire si l'on veut réutiliser un objet et lui appliquer plusieurs transformations ? Ou faire des opérations à partir de différents objets ?

Pour cela, on va assigner les objets à des variables.
Cela permet ensuite de réaliser des opérations à partir de ces variables.

L'assignation se fait suivant le format :

```r
nom_de_la_variable <- objet
```

Le sens de la flèche a une importance et il
est conventionnel de mettre à gauche le nom
de la variable (et donc
d'utiliser `nom_de_la_variable <- objet` plutôt que `objet -> nom_de_la_variable`).

::: {.callout-note}

L'assignation sous la forme `<-` est une spécificité de `R` par rapport
à beaucoup de langages. Dans la plupart des langages informatiques,
comme en `Python` par exemple,
l'assignation se fait avec `=`:

```r
nom_de_la_variable = objet
```

C'est également possible en `R` mais il
est plus conventionnel d'utiliser `<-`.

:::



```{python}
x <- 5
x
```

```{python}
class(x)
```

```{python}
x <- c(5, 10)
```

```{python}
y <- x + 2*x
y
```

Contrairement à d'autres langages de programmation, `R` est dit *dynamiquement* typé : il est possible de réassigner une variable à un objet de type différent. Cela facilite la lecture et le développement, mais peut parfois générer des problèmes difficiles à débugger...
Il faut donc toujours bien faire attention que le type de la variable est bien celui que l'on s'imagine manipuler.

```{python}
x <- 3
x <- "blabla"
class(x)
```

Il y a naturellement certaines contraintes sur les opérations selon les types des objets.

```{python}
#| error: true
x <- "test"
y <- 3
x + y
```

Il est par contre possible d'harmoniser les types en amont :

```{python}
x <- "5"
y <- 3
z <- as.numeric(x)
x + z
```

# Indexation

En `R`, les indices de position dans les vecteurs permettent d'accéder à des éléments spécifiques en utilisant leur position dans le vecteur. 
Les indices commencent à 1, ce qui signifie que le premier élément a un indice de 1, le deuxième a un indice de 2, et ainsi de suite.

```{r}
x <- 2*seq(1,10)
```

Pour accéder à un élément spécifique du vecteur en utilisant son indice de position, on utilise la notation `[ ]`. 
Par exemple, pour obtenir le deuxième élément de `x`, vous pouvez faire ceci :

```{r}
# Accéder au deuxième élément du vecteur
deuxieme_position <- x[2]
deuxieme_position
```

Maintenant, la variable `deuxieme_position` contient la valeur 4.

::: {.callout-note}
On peut d'ailleurs mettre à jour le vecteur `x`, cela ne changera
pas la valeur de la variable `deuxieme_position` :

```{r}
x <- seq(5,9)
print(deuxieme_position)
deuxieme_position == x[2]
```

En `R`, une valeur de variable n'est changée que s'il y a,
d'une manière ou d'une autre, réassignation. 
:::

On peut aussi utiliser une séquence de valeurs pour récupérer
un sous-ensemble de notre vecteur (on appelle cette opération _slice_)

```{r}
x <- seq(5,15)
x[1:5]
x[c(2,3,8)]
```

Il est également possible de faire des sélections négatives, c'est-à-dire
toutes les valeurs sauf certaines. Pour cela, on utilise les indices négatifs

```{r}
x[-3]
x[c(-3, -1)]
```

Cependant, ce n'est pas une bonne pratique d'utiliser de manière 
brute les nombres. En effet, imaginons que vous transformiez
dans une longue chaine d'opérations votre vecteur: vous ne savez
plus forcément quelles positions stockent quelles valeurs (et sur 
les vrais jeux de données vous ne savez même pas exactement quelles
lignes de votre jeu de données stockent quelles valeurs). 

C'est pour cette raison qu'on privilégie les sélections à partir de conditions
logiques. On l'avait vu précédemment sous cette forme :

```{r}
c('Pierre', 'Paul', 'François', 'et les autres')[
    c(25, 3, 61, 17) >= 18
]
```

Maintenant que nous connaissons l'assignation de variables intermédiaires, 
la syntaxe se simplifie.

```{r}
villes <- c("Paris", "Toulouse", "Narbonne", "Foix")
statut <- c("capitale","préfecture","sous-préfecture","préfecture")
villes[statut == "préfecture"]
```

Nous découvrirons lors du prochain chapitre une généralisation de cette
approche avec les __filtres__ de données. 

# Les valeurs manquantes

Les vrais jeux de données ne sont pas toujours complets et le sont
même rarement. Par exemple, 
dans des séries longues de PIB, les valeurs rétrospectives peuvent
manquer pour des pays qui n'existaient pas avant une certaine date. 

Les valeurs manquantes, souvent représentées par `NA` (Not Available) en `R`,
sont un aspect essentiel de la gestion des données et l'une des forces de `R`
est de proposer une gestion cohérente de celles-ci. Par exemple, si on désire
faire la moyenne mondiale des PIB sur une année passée: faut-il exclure ou non les
pays pour lesquels on a pas d'information cette année-là ou renvoyer une erreur ?
La gestion appropriée des valeurs manquantes est cruciale lors de l'analyse de données et de la création de modèles statistiques.

La fonction `is.na()` permet de vérifier si une valeur est manquante dans un vecteur:

```{r}
# Créer un vecteur avec des valeurs manquantes
donnees <- c(10, NA, 30, NA, 50)

is.na(donnees) # Renvoie TRUE pour les valeurs manquantes, FALSE sinon
```

La gestion appropriée des valeurs manquantes est cruciale pour éviter des biais dans les analyses statistiques et pour obtenir des résultats fiables
car les valeurs manquantes sont rarement un hasard: il existe souvent une raison pour lesquelles une valeur est manquante
et l'hypothèse de [_missing at randomn_](https://stefvanbuuren.name/fimd/sec-MCAR.html) est souvent fausse. 

Il existe plusieurs approches pour traiter les valeurs manquantes en fonction de l'objectif d'une analyse. Les trois stratégies les plus courantes sont :

- Suppression des valeurs manquantes : supprimer les lignes contenant des valeurs manquantes à l'aide de la fonction `na.omit()` ou `complete.cases()` (c'est par exemple ce que fait la régression linéaire par défaut dans `R`). Cependant, cette approche peut entraîner une perte d'informations et l'introduction de biais, elle n'est donc pas à faire à la légère.
- Imputation des valeurs manquantes : En faisant des hypothèses sur la distribution sous-jacente des valeurs manquantes, les valeurs de ces dernières peuvent être estimées. La méthode la plus simple est d'imputer à la moyenne ou à la médiane mais il existe des méthodes moins frustres comme la régression ou les méthodes basées sur les voisins les plus proches. Néanmoins cette imputation n'est pas à prendre à la légère car elle change la distribution de la variable observée, ce qui peut avoir un
impact sur les analyses ultérieures, et elle est très dépendante du choix de modélisation. 
- Traiter les valeurs manquantes comme un groupe à part : Dans les statistiques descriptives, il est possible de réaliser des analyses en mettant un groupe où les valeurs manquantes sont fréquentes à part.


# Exercices

:::{.callout-exercice}
## Exercice 2
Afficher le type de `x` lorsque : 

```{r}
#| output: false
x <- 3
x <- "test"
x <- 3.5
```
:::


:::{.callout-exercice}
## Exercice 3

Calculer la somme des longueurs de chacune des chaînes de caractères suivantes : 

- "une première chaîne"
- "et une deuxième"
- "jamais deux sans trois"

```{r}
#| echo: false
#| output: false

x1 <- "une première chaîne"
x2 <- "et une deuxième"
x3 <- "jamais deux sans trois"
nchar(paste(x1, x2, x3, sep = ""))
```
:::


:::{.callout-exercice}
## Exercice 4

Quel est le type adapté pour définir un code postal ?

<details>
<summary>
Aide si vous ne voyez pas où est le problème
</summary>
Faire un test sur les premiers départements, par exemple 02350.
</details>
:::

:::{.callout-exercice}
## Exercice 5
Supprimer les espaces superflus au début et à la fin de la chaîne suivante :

<details>
<summary>Aide, si vous êtes bloqués</summary>
Taper `?trimws()` dans la console pour afficher l'aide de la fonction `trimws()` 
</details>

```{python}
a <- "    Un string très mal formatté.         "
trimws(a)
```
:::

Les fonctions de base de manipulation de données textuelles étant parfois
un peu difficiles d'usage avec `R`, on pourra aller beaucoup plus loin 
lorsqu'on découvrira le package `stringr`.


