---
title: "Manipuler des donn√©es spatiales avec `sf`"
echo: false
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=true&init.personalInit=¬´https%3A%2F%2Fraw.githubusercontent.com%2Flinogaliana%2Fr-geographie%2Fmain%2Fsspcloud%2Finit.sh¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
D√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/wrangling.qmd)
pour afficher les slides en plein √©cran.
</summary>


``` {.yaml code-preview="/slides/wrangling.qmd"}
```

</details>


Dans ce troisi√®me TP,
nous allons apprendre √† importer et
manipuler des donn√©es spatiales avec
{{< fa brands r-project >}}. Ce logiciel propose
des fonctionnalit√©s tr√®s int√©ressantes pour ce type de
donn√©es complexes qui le rendent capable de se comporter
comme un SIG. Gr√¢ce √† la librairie `sf`, une extension
de `dplyr` aux donn√©es spatiales, les
donn√©es g√©ographiques pourront √™tre manipul√©es
comme n'importe quel type de donn√©es avec {{< fa brands r-project >}}.
La complexit√© induite par la dimension spatiale ne sera pas ressentie. 

Si vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},
une version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_TP.html).


```{r}
#| eval: false
remotes::install_github("linogaliana/cartiflette-r")
install.packages("leaflet")
```

Dans ce chapitre, nous allons utiliser les packages
suivants:


```{r}
#| echo: true
#| output: false
library(units)
library(dplyr)
library(sf)
library(ggplot2)
library()
library(cartiflette)
```


::: {.callout-note}

Certains exemples de code pr√©sentent des annotations sur le c√¥t√©,
passez votre souris dessus pour les afficher, comme ci-dessous

```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. Je m'affiche quand on passe la souris sur moi üê≠ !

:::


## Lire et enrichir des donn√©es spatiales

Dans cette partie,
nous utiliserons
les fonds de carte de l'IGN dont
la mise √† disposition est facilit√©e
par le projet [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)[^cartiflette-r].

[^cartiflette-r]:
  La librairie {{< fa brands r-project >}} est exp√©rimentale mais 
  les prochaines semaines devraient permettre de combler ce manque. 
  Une documentation interactive illustrant le code n√©cessaire pour reproduire
  telle ou telle carte est disponible sur [linogaliana.github.io/cartiflette-website](https://linogaliana.github.io/cartiflette-website/index.html).


::: {.callout-tip}
## Exercice 1: lire et explorer la structure de fichiers g√©ographiques

1. S'inspirer des exemples de code pr√©sents dans les slides mobilisant
le package `cartiflette`
pour t√©l√©charger les donn√©es communales des d√©partements 75, 92, 93 et 94.
Vous pouvez nommer l'objet `communes_borders`
2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec
un DataFrame standard. 
3. Afficher le `crs` de `communes_borders`. Ce dernier contr√¥le la
transformation de l'espace tridimensionnel terrestre en une surface plane.
Utiliser `st_transform` pour transformer les donn√©es en Lambert 93, le 
syst√®me officiel (code EPSG 2154). 
4. Afficher les communes des Hauts de Seine (d√©partement 92) et repr√©senter rapidement la carte.
5. R√©pr√©senter la carte de Paris : quel est le probl√®me ?
:::

```{r}
#| output: false
#| label: download-borders-communes
#1) Chargement des donn√©es de Cartiflette
communes_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

```{r}
#| output: false
# 2) Regarder les premi√®res lignes
head(communes_borders)
```

```{r}
#| output: false

# 3) Afficher le crs
sf::st_crs(communes_borders)
# Les donn√©es sont en WGS84, on les reprojette en lambert 93
communes_borders <- communes_borders %>% st_transform(2154)
```


<details>

<summary>
Si vous d√©sirez observer l'aspect de la
carte du 92 (question 4), d√©roulez cette partie.
</summary>

```{r}
#| label: plot-92
#| output: false

# 4) afficher les communes du d√©partement 92
hds <- communes_borders %>% filter(INSEE_DEP == "92")
map_92 <- ggplot(hds) +
    geom_sf(fill = "white") + theme_void()
```

```{r}
map_92
```

</details>

En ce qui concerne Paris, √† l'issue de la question 5, la carte
aura l'aspect suivant:

```{r}
# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?
ggplot(communes_borders %>% filter(INSEE_DEP == "75")) +
    geom_sf(fill = "white") + theme_void()
```



On remarque rapidement le probl√®me. 
On ne dispose ainsi pas des limites des arrondissements parisiens, ce
qui appauvrit grandement la carte de Paris. 

On pourrait les r√©cup√©rer directement 
depuis le site d'_open-data_ du Grand Paris 
mais on propose ici d'utiliser √† nouveau
`cartiflette` afin de disposer du fonds de carte officiel
des arrondissements.




::: {.callout-tip}
## Exercice 2: compl√©ter des donn√©es spatiales issues de sources diff√©rentes

1. Importer les donn√©es de d√©coupage des arrondissements parisiens √† l'adresse √† l'aide de `cartiflette`.
2. V√©rifier sur une carte que les d√©coupages des arrondissements sont bien pr√©sents.
3. V√©rifier l'attribut `crs`. Est-il coh√©rent avec celui des donn√©es communales ?
Si non, transformer en Lambert 93 (code EPSG 2154).
4. Retirer Paris du jeu de donn√©es communales et utiliser les arrondissements
pour enrichir (nommer l'objet obtenu `data_borders`). 
5. Repr√©senter √† nouveau les communes de la petite couronne parisienne (75, 92, 93, 94)

:::


```{r}
library(cartiflette)

# Question 1
arrondissements = download_vectorfile_url_all(
    crs = 4326,
    values = "75",
    borders="ARRONDISSEMENT_MUNICIPAL",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)

arrondissements
```



```{r}
ggplot(arrondissements) + geom_sf(fill = "white") + theme_void()
```

```{r}
#| output: false
#3) V√©rifier l'attribut `crs`. Est-il coh√©rent ?
print(st_crs(communes_borders))
print(st_crs(arrondissements))

arrondissements <- arrondissements %>% st_transform(2154)
print(st_crs(communes_borders) == st_crs(arrondissements))
```


```{r}
#4) Retirer Paris et ajouter les arrondissements
data_paris <- dplyr::bind_rows(
  communes_borders %>% filter(INSEE_DEP != "75"),
  arrondissements
)
```

La carte de Paris intra-muros est, apr√®s la
r√©cup√©ration des arrondissements avec
`cartiflette` de ce type l√†:

```{r}
ggplot(data_paris) +
    geom_sf(fill = "white") + theme_void()
```


## Utiliser des donn√©es g√©ographiques comme des couches graphiques


Souvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des
rep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter
un autre jeu de donn√©es.

On va partir des donn√©es de localisation des
stations velib, 
disponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et 
requ√™tables directement par l'url
<https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr>

```{r}
url <- "https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
```

::: {.callout-tip}
## Exercice 3: importer et explorer les donn√©es velib

1. Importer les donn√©es velib sous le nom `station`
2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces
derni√®res dans le m√™me syst√®me de projection que les stations de v√©lib
3.  Repr√©senter sur une carte les 50 stations les plus importantes (variable `capacity`). Vous pouvez √©galement afficher le fonds de carte des arrondissements de Paris.
Cette [page](https://geopandas.org/mapping.html#maps-with-layers) peut vous aider pour comprendre comment afficher plusieurs couches √† la fois. Vous pouvez customiser la carte en retirant les axes gr√¢ce √† la m√©thode `set_axis_off` et mettre un titre tel que _"Les 50 principales stations de V√©lib"_ avec la m√©thode `set_title`. 
4. Afficher √©galement (trait bleu et √©pais) les r√©seaux de transport en communs, disponibles [ici](https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/map/?location=7,48.69717,2.33167&basemap=jawg.streets). L'url √† requ√™ter est
<https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr>
:::



```{r}
#| output: false
# 1) Importer les donn√©es velib
stations <- st_read(url)
```

```{r}
head(stations)
```


```{r}
# 2) Reprojection
st_crs(stations)
stations <- stations %>% 
  st_transform(st_crs(data_paris))
```

La carte attendu √† l'issue de la question 3 a l'aspect suivant:


```{r}
# 3) Carte des 50 stations les plus importantes. 

paris <- data_paris %>%
  filter(INSEE_DEP == "75")

principales_stations <- stations %>%
  arrange(desc(capacity)) %>%
  head(50)

ggplot(paris) +
  geom_sf(fill = "white") + geom_sf(data = principales_stations) + 
  theme_void()
```


```{r}
# 4) R√©seaux de transport en communs
url <- "https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr"

transports <- st_read(url) %>%
  st_transform(2154)
```

L'ajout du r√©seau de m√©tro permet d'obtenir une carte ressemblant √† celle-ci:


```{r}
metro <- transports %>% filter(mode == "METRO")

ggplot(paris) +
  geom_sf(fill = "white") + geom_sf(data = principales_stations, color = "red") + 
  geom_sf(data = metro, color = "royalblue", alpha = 0.4) +
  theme_void()
```

Pour faire une belle carte, il faudrait couper les lignes de m√©tro
via une jointure spatiale ou privil√©gier
un fonds de carte conceptuel. 
La m√©thode pour faire des cartes contextuelles
est propos√©e en [exercice suppl√©mentaire üëáÔ∏è](#exo-supp).
puisqu'elle implique des connaissances minimales avec `leaflet`
que nous verrons ult√©rieurement.

## Jointures spatiales

Les jointures attributaires fonctionnent comme avec un `tibble` classique.
Pour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `sf`.
En revanche, l'un des int√©r√™ts des objets geopandas est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† plusieurs fonctions:

| Fonction |	Op√©ration |
|----------|------------|
|`st_intersects()` | 	Quelles g√©om√©tries de x intersectent celles de y ? |
|`st_contains()` | 	Quelles g√©om√©tries de x contiennent celles de y ? |
|`st_disjoint()` | 	Quelles g√©om√©tries de x sont disjointes √† celles de y ? |
|`st_is_within_distance()` | 	Quelles g√©om√©tries de x est √† moins de 
m/km de celles de y ? |

La documentation √† laquelle se
r√©f√©rer est [ici](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn03_join_filter.html). 
Une version p√©dagogique se trouve dans la documentation [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_spatiales#joindre-des-donn%C3%A9es-g%C3%A9ographiques-et-attributaires). 


::: {.callout-tip}
## Exercice 4: Associer les stations aux communes et arrondissements auxquels elles appartiennent

1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `data_paris`. Appeler cet objet `stations_info`
2. Repr√©senter la carte des stations du 19e arrondissement (s'aider de la variable `NOM`). Vous pouvez mettre en fond de carte les arrondissements parisiens. 
3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune (pour vous aider, vous pouvez compl√©ter vos connaissances avec [ce tutoriel](https://pandas.pydata.org/docs/getting_started/intro_tutorials/06_calculate_statistics.html)). Repr√©senter sur une carte chacune des informations
4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)
5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)

:::

```{r}
stations_info <- st_join(stations, data_paris, join = st_within)
```

Pour la question 2,
la premi√®re m√©thode consiste √† afficher
toute la ville mais √† ne repr√©senter que
les points des stations du 19e:

```{r}
stations_19e <- stations_info %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)
arrondissement_19e <- data_paris %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)

leaflet(stations_19e) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    radius = ~sqrt(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5) %>%
  addPolylines(data = arrondissement_19e)
```

```{r}
# Question 3
stations_agg <- stations_info %>%
  group_by(NOM) %>%
  mutate(stationcode_count = n_distinct(stationcode),
            capacity_sum = sum(capacity)) %>%
  st_drop_geometry()

data_paris <- data_paris %>%
  mutate(area = units::set_units(st_area(.), "km^2"))
df <- data_paris %>% left_join(stations_agg)
```

Enfin, dans la question 4,
si on repr√©sente plut√¥t la capacit√© 
sous forme de densit√©, pour tenir compte
de la taille diff√©rente des arrondissements,
on obtient cette carte:

```{r}
df %>% mutate(capacity_density = capacity/area)
```




## Exercices suppl√©mentaires

```{r}
library(leaflet)

pal_fun <- colorQuantile("YlOrRd", NULL, n = 4)
principales_stations_wgs84 <- principales_stations %>%
  st_transform(4326)

leaflet(principales_stations_wgs84) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5)
```

