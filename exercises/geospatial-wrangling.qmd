---
title: "Manipuler des donn√©es spatiales avec `sf`"
echo: true
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.13&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
D√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/geospatial.qmd)
pour afficher les slides en plein √©cran.
</summary>


``` {.yaml code-preview="/slides/geospatial.qmd"}
```

</details>


Dans ce TP,
nous allons apprendre √† importer et
manipuler des donn√©es spatiales avec
{{< fa brands r-project >}}.

Ce logiciel propose
des fonctionnalit√©s tr√®s int√©ressantes pour ce type de
donn√©es complexes qui le rendent capable de se comporter
comme un SIG. Gr√¢ce √† la librairie [`sf`](https://r-spatial.github.io/sf/), une extension
de `dplyr` aux donn√©es spatiales, les
donn√©es g√©ographiques pourront √™tre manipul√©es
comme n'importe quel type de donn√©es avec {{< fa brands r-project >}}.
La complexit√© induite par la dimension spatiale ne sera pas ressentie. 


<details>
<summary>
`sf`, une association de tables de donn√©es classiques √† des g√©om√©tries
</summary>
![](https://user-images.githubusercontent.com/520851/50280460-e35c1880-044c-11e9-9ed7-cc46754e49db.jpg){width="70%"}
</details>

Si vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},
une version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_TP.html).


```{r}
#| eval: false
#| echo: true
remotes::install_github("linogaliana/cartiflette-r")
install.packages("leaflet")
```

Dans ce chapitre, nous allons utiliser les packages
suivants:


```{r}
#| echo: true
#| output: false
library(units)
library(dplyr)
library(sf)
library(ggplot2)
library(mapsf)
library(leaflet)
library(cartiflette)
```

Ce chapitre illustre √† partir d'exemples pratiques certains principes
centraux de l'analyse de donn√©es:

- Manipulations sur les attributs des jeux de donn√©es ;
- Manipulations g√©om√©triques ;
- Gestion des projections cartographiques ;
- Cr√©ation rapide de cartes (ce sera approfondi dans un prochain chapitre).


::: {.callout-note collapse="true"}
## Note sur les annotations

Certains exemples de code pr√©sentent des annotations sur le c√¥t√©,
passez votre souris dessus pour les afficher, comme ci-dessous

```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. Je m'affiche quand on passe la souris sur moi üê≠ !

:::


## D√©couverte des objets g√©ographiques 

Dans cette partie,
nous utiliserons
les fonds de carte de l'IGN dont
la mise √† disposition est facilit√©e
par le projet [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)[^cartiflette-r].

[^cartiflette-r]:
  La librairie {{< fa brands r-project >}} est exp√©rimentale mais 
  les prochaines semaines devraient permettre de combler ce manque. 
  Une documentation interactive illustrant le code n√©cessaire pour reproduire
  telle ou telle carte est disponible sur [linogaliana.github.io/cartiflette-website](https://linogaliana.github.io/cartiflette-website/index.html).


::: {.callout-tip}
## Exercice 1: d√©couverte des objets g√©ographiques

En premier lieu, on r√©cup√®re des donn√©es g√©ographiques gr√¢ce
au _package_ `cartiflette`.

1. Utiliser
le code ci-dessous pour
t√©l√©charger les donn√©es communales (produit `Admin Express` de l'IGN)
des d√©partements de la petite couronne (75, 92, 93 et 94)
de mani√®re simplifi√©e gr√¢ce au _package_
`cartiflette`:

```{r}
#| echo: true
#| output: false
#| label: download-borders-communes
# 1. Chargement des donn√©es de cartiflette
communes_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec
un _dataframe_ standard. 

```{r}
#| code-fold: true
#| code-summary: "Solution question 2"
#| output: false
# 2) Regarder les premi√®res lignes
head(communes_borders)
```

<details>
<summary>
Premi√®res lignes des donn√©es
</summary>
```{r}
#| echo: false
# 2) Regarder les premi√®res lignes
head(communes_borders)
```
</details>

3. Afficher le `crs` de `communes_borders`. Ce dernier contr√¥le la
transformation de l'espace tridimensionnel terrestre en une surface plane.
Utiliser `st_transform` pour transformer les donn√©es en Lambert 93, le 
syst√®me officiel (code EPSG 2154). 

```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution question 3"

# 3) Afficher le crs
sf::st_crs(communes_borders)
# Les donn√©es sont en WGS84, on les reprojette en lambert 93
communes_borders <- communes_borders %>% st_transform(2154)
```

4. Afficher les communes des Hauts de Seine (d√©partement 92) et repr√©senter rapidement la carte.

```{r}
#| label: plot-92
#| output: false
#| code-fold: true
#| code-summary: "Solution question 4"

# 4) afficher les communes du d√©partement 92
hds <- communes_borders %>% filter(INSEE_DEP == "92")
map_92 <- ggplot(hds) +
    geom_sf(fill = "white") + theme_void()
```

5. Ne conserver que Paris et r√©pr√©senter les fronti√®res sur une carte : quel est le probl√®me pour
une analyse de Paris intramuros?

```{r}
#| code-fold: true
#| code-summary: "Solution question 5"
paris_raw <- communes_borders %>% filter(INSEE_DEP == "75")
map_paris_raw <- ggplot(paris_raw) +
    geom_sf(fill = "white") + theme_void()
```

On remarque rapidement le probl√®me. 
On ne dispose ainsi pas des limites des arrondissements parisiens, ce
qui appauvrit grandement la carte de Paris. 

6. Cette fois, utiliser l'argument `borders="COMMUNE_ARRONDISSEMENT"` pour obtenir
un fonds de carte consolid√© des communes avec les arrondissements dans les grandes villes. 
Convertir en Lambert 93. 

```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution question 6"

petite_couronne <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE_ARRONDISSEMENT",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022) %>%
  st_transform(2154)
petite_couronne_mercator <- petite_couronne %>%
  st_transform(4326)

map_paris_arrondissements <- ggplot(petite_couronne) +
    geom_sf(fill = "white") + theme_void()
```


:::


<details>

<summary>
Si vous d√©sirez observer l'aspect de la
carte du 92 (question 4), d√©roulez cette partie.
</summary>

```{r}
#| echo: false
map_92
```

</details>

<details>
<summary>
Carte de Paris attendue √† la question 5 et √† la question 6
</summary>

A la question 5, Paris intra-muros est bien pauvre: 

```{r}
#| echo: false
# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?
map_paris_raw
```

A l'issue de la  question 6, on a bien une carte de la petite couronne avec
des arrondissements:

```{r}
#| echo: false
# 6) Repr√©senter la carte de Paris avec arrondissements
map_paris_arrondissements
```


</details>

## Le syst√®me de projection

Un concept central dans les logiciels de SIG est la notion de 
__projection__. L'exercice pr√©c√©dent imposait parfois certaines projections
sans expliquer l'importance de ces choix. {{< fa brands r-project >}}, comme
tout SIG, permet une gestion coh√©rente des projections. 

L'exercice suivant vise √† introduire aux principales
fonctionnalit√©s de {{< fa brands r-project >}}
√† ce propos. Il illustre les probl√®mes communs que peuvent rencontrer
les g√©ographes dans la gestion des syst√®mes de projection. 

Observez les variations significatives
de proportions pour certains pays selon les projections
choisies:

```{ojs}
//| echo: false
html`<div>${container_projection}</div>`
``` 

{{< include "../utils/play_projection_d3.qmd" >}}

```{ojs}
//| echo: false
width_projected_map = screen.width/2
```



::: {.callout-tip}
## Exercice 2: Les projections, repr√©sentations et approximations

Voici un code utilisant encore
`cartiflette` 
pour r√©cup√©rer les fronti√®res fran√ßaises (d√©coup√©es par r√©gion):

```{r}
#| output: false
#| echo: true
france <- download_vectorfile_url_all(
      values = "metropole",
      crs = 4326,
      borders = "REGION",
      vectorfile_format="geojson",
      filter_by="FRANCE_ENTIERE",
      source="EXPRESS-COG-CARTO-TERRITOIRE",
      year=2022)
```

```{r}
# eval: true
st_crs(france) <- 4326
st_crs(france$geometry) <- 4326
```

1. S'amuser √† repr√©senter les limites de la France avec plusieurs projections:

- Mercator WGS84 (EPSG: 4326)
- Projection healpix (`+proj=healpix +lon_0=0 +a=1`)
- Projection pr√©vue pour Tahiti (EPSG: 3304)
- Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)

2. Utiliser la fonction `st_area` sur calculer la superficie en $km^2$
des r√©gions fran√ßaises dans les deux syst√®mes de projection suivants: 
WGS84 (EPSG: 4326) et Lambert 93 (EPSG: 2154). Calculer la diff√©rence en $km^2$
pour chaque r√©gion.
:::

```{r}
#| code-fold: true
#| code-summary: "Solution question 1"
#| eval: false
#| output: false
france_2154 <- france %>% sf::st_transform(2154)
france_healpix <- france %>% sf::st_transform("+proj=healpix +lon_0=0 +a=1")
france_5070 <- france %>% sf::st_transform(5070)
france_3304 <- france %>% sf::st_transform(3304)
```

Avec la question 1 illustrant quelques cas pathologiques,
on comprend que les projections ont un effet d√©formant
qui se voit bien lorsqu'on les repr√©sente c√¥te √† c√¥te sous
forme de cartes :

```{r}
#| eval: false
#| label: fig-effet-mercator
#| fig-cap: "Comparaison des projections"
#| fig-subcap: 
#|   - "Mercator WGS84 (EPSG: 4326)"
#|   - "Projection healpix (+proj=healpix +lon_0=0 +a=1)"
#|   - "Projection pr√©vue pour Tahiti (EPSG: 3304)"
#|   - "Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)"
#| layout-ncol: 2

ggplot(france) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_healpix) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_3304) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_5070) +
    geom_sf(fill = "white") + theme_void()
```

```{r}
#| code-fold: true
#| code-summary: "Solution question 2"

mismatch_france <- france %>%
  mutate(superficie_4326 = set_units(st_area(.), "km^2")) %>%
  st_transform(2154) %>%
  mutate(superficie_2154 = set_units(st_area(.), "km^2")) %>%
  mutate(mismatch = superficie_2154-superficie_4326) %>%
  select(NOM, superficie_4326, superficie_2154, mismatch)
```

Cependant le probl√®me n'est pas que visuel, il est √©galement
num√©rique. Les calculs g√©om√©triques am√®nent √† des diff√©rences
assez notables selon le syst√®me de r√©f√©rence utilis√©.

<details>
<summary>
Voir le tableau des approximations pour chaque r√©gion
</summary>
```{r}
mismatch_france %>% arrange(desc(mismatch))
```
</details>

On peut repr√©senter ces approximations sur une carte[^notecarte] pour se faire
une id√©e des r√©gions o√π l'erreur de mesure est la plus importante.

[^notecarte]: Cette carte n'est pas trop soign√©e,
c'est normal nous verrons comment
faire de belles cartes ult√©rieurement.

```{r}
#| code-fold: true
#| code-summary: "Solution question 2, suite"

#| label: fig-erreur-mesure
#| fig-cap: Approximations li√©es au syst√®me de projection WGS 84
ggplot(mismatch_france) +
  geom_sf(aes(fill = as.numeric(mismatch))) +
  scale_fill_gradient2() +
  labs(title = "Approximations li√©es √† la projection", fill = "km¬≤") +
  theme_void() + theme(legend.position = "bottom")
```

Ce type d'erreur de mesure est normal √† l'√©chelle du territoire fran√ßais. 
Les projections h√©rit√®res du Mercator d√©forment les distances,
surtout lorqu'on se rapproche de l'√©quateur ou des p√¥les. 

::: {#fig-mercator}

![Exemple de reprojection de pays depuis le site [thetruesize.com](https://www.thetruesize.com/)](https://pythonds.linogaliana.fr/content/manipulation/truesize.png){#fig-surus}

!["Don't trust the Mercator projection" sur `Reddit`](img/mercator.jpg){#fig-mercator-funny}

La projection Mercator, une vision d√©formante
:::

Pour aller plus loin, la carte interactive
suivante, construite par Nicolas Lambert, issue de
ce [_notebook_ `Observable`](https://observablehq.com/@neocartocnrs/impact-of-projections-on-areas), illustre l'effet
d√©formant de la projection Mercator, et de quelques unes autres,
sur notre perception de la taille des pays.

<details>
<summary>
Voir la carte interactive
</summary>
```{ojs}
html`<div class="grid-container">
  <div class="viewof-projection">${viewof projectionBertin}</div>
  <div class="viewof-mycountry">${viewof mycountry}</div>
  <div class="map-bertin">${mapBertin}</div>
</div>`
```

</details>

```{ojs}
import {map as mapBertin, viewof projection as projectionBertin, viewof mycountry} from "@neocartocnrs/impact-of-projections-on-areas"
```



Il n'est donc pas suprenant que nos d√©formations soient exacerb√©es aux
extr√®mes du territoire m√©tropolitain. 
Si les approximations sont l√©g√®res sur de petits territoires,
les erreurs peuvent √™tre 
non n√©gligeables √† l'√©chelle de la France.

Il faut donc syst√©matiquement
repasser les donn√©es dans le syst√®me de projection Lambert 93 (le
syst√®me officiel pour la m√©tropole) avant d'effectuer des calculs g√©om√©triques.



## Utiliser des donn√©es g√©ographiques comme des couches graphiques


Souvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des
rep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter
un autre jeu de donn√©es.

On va partir des donn√©es de localisation des
stations velib, 
disponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et 
requ√™tables directement en utilisant un URL


```{r}
#| echo: true
url <- "https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
```


Dans le prochain exercice, nous proposons de cr√©er rapidement une 
carte comprenant trois couches:

- Les localisations de stations sous forme de points ;
- Les bordures des communes et arrondissements pour contextualiser ;
- Les bordures des d√©partements en traits plus larges pour contextualiser √©galement. 

Nous irons plus loin dans le travail cartographique dans le prochain
chapitre. Mais √™tre en mesure de positionner rapidement
ses donn√©es sur une carte est
toujours utile dans un travail exploratoire. 

En amont de l'exercice,
utiliser la fonction suivante du _package_ `cartiflette` pour r√©cup√©rer
le fonds de carte des d√©partements de la petite couronne:

```{r}
#| echo: true
#| output: false
idf <- download_vectorfile_url_all(
      values = "11",
      crs = 4326,
      borders = "DEPARTEMENT",
      vectorfile_format="geojson",
      filter_by="REGION",
      source="EXPRESS-COG-CARTO-TERRITOIRE",
      year=2022)
petite_couronne_departements <- idf %>%
  filter(INSEE_DEP %in% c("75","92","93","94"))
```



::: {.callout-tip}
## Exercice 3: importer et explorer les donn√©es velib

On commence par r√©cup√©rer les donn√©es n√©cessaires √† la production
de cette carte.

1. En utilisant l'URL pr√©c√©dent, importer les donn√©es velib sous le nom `station`
2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces
derni√®res dans le m√™me syst√®me de projection que les stations de v√©lib
3. Ne conserver que les 50 principales stations (variable `capacity`)

On peut maintenant construire la carte de mani√®re s√©quentielle avec `ggplot`

4. En premier lieu, gr√¢ce √† `geom_sf`, 
repr√©senter exclusivement les positions des stations
et ajuster la taille en fonction de la variable `capacity`

5. Ajouter la couche des communes d'arrondissements et des communes
    + Comme ces limites administratives sont stock√©es dans un _dataframe_ diff√©rent, il va falloir utiliser l'argument `data`
    + Utiliser `fill = "transparent"` pour que l'int√©rieur du polygone ne masque pas nos points

6. Ajouter la couche des d√©partements

7. En supposant que votre objet `ggplot` s'appelle `carte`, vous pouvez
utiliser le code suivant pour am√©liorer rapidement l'esth√©tique

```r
carte +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(color = "none", size = guide_legend(title.position="top", title.hjust = 0.5)) +
  labs(size = "Capacit√© de la station", title = "Les 50 principales stations de v√©lib")
```


:::

```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution question 1"
# 1. Importer les donn√©es velib
stations <- st_read(url)
```

```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution question 2"
# 2. Reprojection
st_crs(stations)
stations <- stations %>% 
  st_transform(st_crs(petite_couronne))
```


```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution question 3"
# 3. Principales stations
principales_stations <- stations %>%
  arrange(desc(capacity)) %>%
  head(50)
```


```{r}
#| code-fold: true
#| code-summary: "Solution question 4"
# 4. Principales stations sous forme de nuage de points
carte <- ggplot(principales_stations) +
  geom_sf(aes(color = "red", size = capacity))
```

<details>
<summary>
Les stations plac√©es sur un plan, √† l'issue de la question 4
</summary>
```{r}
carte
```
</details>

```{r}
#| code-fold: true
#| code-summary: "Solution question 5"
# Question 5
carte <- carte + geom_sf(data = petite_couronne, fill = "transparent")
```

<details>
<summary>
Ajout d'une couche d'arrondissements (question 5)
</summary>

```{r}
carte
```
</details>

```{r}
#| code-fold: true
#| code-summary: "Solution question 6"
# Question 6
carte <- carte +
  geom_sf(data = petite_couronne_departements, fill = "transparent", color = "blue")
```

<details>
<summary>
Ajout de la couche des d√©partements (question 6)
</summary>

```{r}
carte
```

</details>

La carte finalis√©e (question 7), obtenue gr√¢ce √† une demi-douzaine de lignes
de code seulement, est ainsi:

```{r}
#| code-fold: true
#| code-summary: "Solution question 7"
# Question 7
carte +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(color = "none", size = guide_legend(title.position="top", title.hjust = 0.5)) +
  labs(size = "Capacit√© de la station", title = "Les 50 principales stations de v√©lib")
```




## Jointures spatiales

Les jointures attributaires fonctionnent comme avec un `tibble` classique.
Pour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `sf`.
En revanche, l'un des int√©r√™ts des objets `sf` est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† plusieurs fonctions. Les jointures les plus communes sont:

| Fonction |	Op√©ration |
|----------|------------|
|`st_intersects()` | 	Quelles g√©om√©tries de x intersectent celles de y ? |
|`st_contains()` | 	Quelles g√©om√©tries de x contiennent celles de y ? |
|`st_disjoint()` | 	Quelles g√©om√©tries de x sont disjointes √† celles de y ? |
|`st_is_within_distance()` | 	Quelles g√©om√©tries de x est √† moins de m/km de celles de y ? |

La documentation √† laquelle se
r√©f√©rer est [ici](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn03_join_filter.html). 
Une version p√©dagogique se trouve dans la documentation [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_spatiales#joindre-des-donn%C3%A9es-g%C3%A9ographiques-et-attributaires). 


::: {.callout-tip}
## Exercice 4: Associer les stations aux communes et arrondissements auxquels elles appartiennent

Dans cet exercice, on va supposer que :

- les localisations des stations `velib` 
sont stock√©es dans un _dataframe_ nomm√© `stations`
- les donn√©es administratives
sont dans un _dataframe_ nomm√© `petite_couronne`.

1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `petite_couronne`. Appeler cet objet `stations_info`
2. Cr√©er les objets `stations_19e` et `arrondissement_19e` pour stocker, respectivement, 
les stations appartenant au 19e et les limites de l'arrondissement
2. Repr√©senter la carte des stations du 19e arrondissement avec le code suivant:

```r
petite_couronne %>% filter(INSEE_DEP == 75) %>%
  ggplot() +
    geom_sf(aes(fill = grepl("19e", NOM)), alpha = 0.1) +
    geom_sf(data = stations_19e, color = "royalblue") +
    scale_fill_viridis_d() +
    theme_void() +
    theme(legend.position = "none")
```

3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune. Repr√©senter sur une carte chacune des informations
4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)
5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)

:::

```{r}
#| code-fold: true
#| code-summary: "Solution question 1"
stations_info <- st_join(stations, petite_couronne, join = st_within)
```

```{r}
#| code-fold: true
#| code-summary: "Solution question 2"
stations_19e <- stations_info %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)
arrondissement_19e <- petite_couronne %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)
```


<details>
<summary>
La carte obtenue sur la question 2 
</summary>

```{r}
#| code-fold: true
#| code-summary: "Solution question 2, suite"
petite_couronne %>% filter(INSEE_DEP == 75) %>%
  ggplot() +
    geom_sf(aes(fill = grepl("19e", NOM)), alpha = 0.1) +
    geom_sf(data = stations_19e, color = "royalblue") +
    scale_fill_viridis_d() +
    theme_void() +
    theme(legend.position = "none")
```
</details>

<details>
<summary>
Une version interactive produite avec `leaflet`, que nous d√©couvrirons
prochainement.
</summary>

```{r}
#| code-fold: true
#| code-summary: "Solution question 2, version interactive"
pal_fun <- colorQuantile("YlOrRd", NULL, n = 4)

leaflet(stations_19e) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    radius = ~sqrt(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5) %>%
  addPolylines(data = arrondissement_19e)
```
</details>

```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution question 3"
# Question 3
stations_agg <- stations_info %>%
  group_by(INSEE_COG) %>%
  summarise(stationcode_count = n_distinct(stationcode),
            capacity_sum = sum(capacity)) %>%
  st_drop_geometry()

petite_couronne <- petite_couronne %>%
  mutate(area = units::set_units(st_area(.), "km^2"))
df <- petite_couronne %>% left_join(stations_agg)
```

<details>
<summary>
La carte obtenue √† la question 3
</summary>

```{r}
df %>% filter(INSEE_DEP == 75) %>%
  ggplot() +
    geom_sf(aes(fill = capacity_sum)) +
    scale_fill_viridis_c() +
    theme_void() +
    theme(legend.position = "bottom")
```
</details>

Avec la carte de la question 3, bas√©e sur des aplats de
couleurs (_choropleth map_), le lecteur est victime d'une illusion
classique. Les arrondissements les plus visibles sur la carte sont les
plus grands. D'ailleurs c'est assez logique qu'ils soient √©galement mieux
pourvus en velib. M√™me si l'offre de velib est probablement plus reli√©e
√† la densit√© de population et d'√©quipements, on peut penser que l'effet
taille joue et qu'ainsi on est victime d'une illusion avec la carte pr√©c√©dente.

Si on repr√©sente plut√¥t la capacit√© 
sous forme de densit√©, pour tenir compte
de la taille diff√©rente des arrondissements,
les conclusions sont invers√©es et correspondent
mieux aux attentes d'un mod√®le centr-p√©riph√©rie. Les
arrondissements centraux sont mieux pourvus, cela se voit
encore mieux avec des ronds proportionnels plut√¥t qu'une
carte chorol√®pthe. 

```{r}
#| code-fold: true
#| code-summary: "Solution question 4"
df <- df %>% mutate(capacity_density = capacity_sum/as.numeric(area))
```

```{r}
#| label: fig-density-velib
#| fig-cap: "Densit√© de velib dans l'agglom√©ration parisienne"
#| fig-subcap: 
#|   - "Aplat de couleur"
#|   - "Ronds proportionnels"
#| layout-ncol: 2
#| code-fold: true
#| code-summary: "Solution question 4, fin"

df %>% filter(INSEE_DEP == 75) %>%
  ggplot() +
    geom_sf(aes(fill = capacity_density)) +
    scale_fill_viridis_c() +
    theme_void() +
    theme(legend.position = "bottom")

mf_map(x = df %>% filter(INSEE_DEP == 75))
mf_map(
  x = df %>% filter(INSEE_DEP == 75),
  var = "capacity_density",
  type = "prop"
)
```

## Exercice suppl√©mentaire

Les exercices pr√©c√©dents ont permis de se familiariser au traitement de donn√©es
spatiales. N√©anmoins il arrive de devoir jongler plus avec la
dimension g√©om√©trique par exemple pour changer d'√©chelle ou introduire
des fusions/dissolutions de g√©om√©tries.

Imaginons que chaque utilisateur de velib se d√©place exclusivement
vers la station la plus proche (√† supposer qu'il n'y a jamais p√©nurie
ou surcapacit√©). Quelle est la carte de la couverture des v√©libs ? 
Pour r√©pondre √† ce type de question, on utilise fr√©quemment la
la [tesselation de Vorono√Ø](https://fr.wikipedia.org/wiki/Diagramme_de_Vorono%C3%AF),
une op√©ration classique pour transformer des points en polygones. L'exercice suivant
permet de se familiariser avec cette approche[^notevoronoi].


[^notevoronoi]: Dans [ce document de travail](https://www.insee.fr/en/statistiques/4925202) sur donn√©es de t√©l√©phonie mobile, on montre n√©anmoins que cette approche n'est pas sans biais
sur des ph√©nom√®nes o√π l'hypoth√®se de proximit√© spatiale est
trop simplificatrice.


::: {.callout-tip}
## Exercice 5: la tesselation de Vorono√Ø

A l'aide de [cet article](https://www.jla-data.net/eng/spatial-aggregation/), 
cr√©er progressivement votre tesselation de voronoi

1. Construire une enveloppe nomm√©e `petite_couronne_limites` en utilisant
la fonction `st_union` sur notre fonds de carte des communes de la petite
couronne
2. Cr√©er la tesselation de voronoi en ex√©cutant les √©tapes suivantes:
    + Ne conserver que les g√©om√©tries avec `st_geometry`
    + Changer le type d'objet `sf` sous-jacent avec `st_union`
    + Appliquer la transformation avec `st_voronoi`
    + Transformer √ßa en objet `sf` auquel on est plus coutumier avec `st_collection_extract(type = "POLYGON")` puis `st_sf()`
    + Appliquer un masque pour couper les parties ext√©rieures √† la petite couronne avec `st_intersection(petite_couronne_limites)`
    + Joindre √† nouveau aux donn√©es initiales avec `st_join(stations_info)` pour retrouver les attributs pr√©c√©dents

```{r}
#| code-fold: true
#| code-summary: "Solution question 1"
petite_couronne_limites <- petite_couronne %>% st_union()

voronoi <- stations_info %>% 
  st_geometry() %>% # to get sfc from sf
  st_union() %>% # to get a sfc of MULTIPOINT type
  st_voronoi(envelope = st_geometry(petite_couronne_limites)) %>% # NC sized Voronoi polygon
  st_collection_extract(type = "POLYGON") %>% # a list of polygons
  st_sf() %>% # from list to sf object
  st_intersection(petite_couronne_limites) %>% # cut to shape
  st_join(stations_info) # put names back
```

3. Du fait de la densit√© des stations dans Paris intramuros, une carte
au niveau global serait illisible. Il est plus pratique d'avoir une
carte _web_ dans laquelle il est possible de naviguer. 
Utiliser le code suivant pour g√©n√©rer cette carte avec `leaflet`: 

```{r}
#| code-fold: true
#| code-summary: "Solution question 2"
#| echo: true
voronoi_velib <- voronoi %>% st_transform(4326) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(
    fillOpacity = 0.1,
    popup = ~paste0(name, ": ", capacity, " v√©los disponibles"),
    stroke = TRUE, weight = 1)
```

:::

A vous d'observer la zone de chalandise de la station la plus
proche de chez vous :

```{r}
voronoi_velib
```
