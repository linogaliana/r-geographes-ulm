---
title: "Manipuler des donn√©es spatiales avec `sf`"
echo: false
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=true&init.personalInit=¬´https%3A%2F%2Fraw.githubusercontent.com%2Flinogaliana%2Fr-geographie%2Fmain%2Fsspcloud%2Finit.sh¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
D√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/wrangling.qmd)
pour afficher les slides en plein √©cran.
</summary>


``` {.yaml code-preview="/slides/wrangling.qmd"}
```

</details>


Dans ce TP,
nous allons apprendre √† importer et
manipuler des donn√©es spatiales avec
{{< fa brands r-project >}}.

Ce logiciel propose
des fonctionnalit√©s tr√®s int√©ressantes pour ce type de
donn√©es complexes qui le rendent capable de se comporter
comme un SIG. Gr√¢ce √† la librairie [`sf`](https://r-spatial.github.io/sf/), une extension
de `dplyr` aux donn√©es spatiales, les
donn√©es g√©ographiques pourront √™tre manipul√©es
comme n'importe quel type de donn√©es avec {{< fa brands r-project >}}.
La complexit√© induite par la dimension spatiale ne sera pas ressentie. 

<details>
<summary>
`sf`, une association de tables de donn√©es classiques √† des g√©om√©tries
</summary>
![](https://user-images.githubusercontent.com/520851/50280460-e35c1880-044c-11e9-9ed7-cc46754e49db.jpg){width="70%"}
</details>

Si vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},
une version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_TP.html).


```{r}
#| eval: false
remotes::install_github("linogaliana/cartiflette-r")
install.packages("leaflet")
```

Dans ce chapitre, nous allons utiliser les packages
suivants:


```{r}
#| echo: true
#| output: false
library(units)
library(dplyr)
library(sf)
library(ggplot2)
library(leaflet)
library(cartiflette)
```


::: {.callout-note collapse="true"}
## Note sur les annotations

Certains exemples de code pr√©sentent des annotations sur le c√¥t√©,
passez votre souris dessus pour les afficher, comme ci-dessous

```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. Je m'affiche quand on passe la souris sur moi üê≠ !

:::


## D√©couverte des objets g√©ographiques 

Dans cette partie,
nous utiliserons
les fonds de carte de l'IGN dont
la mise √† disposition est facilit√©e
par le projet [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)[^cartiflette-r].

[^cartiflette-r]:
  La librairie {{< fa brands r-project >}} est exp√©rimentale mais 
  les prochaines semaines devraient permettre de combler ce manque. 
  Une documentation interactive illustrant le code n√©cessaire pour reproduire
  telle ou telle carte est disponible sur [linogaliana.github.io/cartiflette-website](https://linogaliana.github.io/cartiflette-website/index.html).


::: {.callout-tip}
## Exercice 1: d√©couverte des objets g√©ographiques

En premier lieu, on r√©cup√®re des donn√©es g√©ographiques gr√¢ce
au _package_ `cartiflette`.

1. S'inspirer des exemples de code pr√©sents dans les slides mobilisant
le package `cartiflette`
pour t√©l√©charger les donn√©es communales (produit `Admin Express` de l'IGN)
des d√©partements de la petite couronne (75, 92, 93 et 94). L'argument √† utiliser
dans cet exercice est `borders="COMMUNE"`
Vous pouvez nommer l'objet `communes_borders`.

```{r}
#| output: false
#| label: download-borders-communes
# 1. Chargement des donn√©es de cartiflette
communes_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec
un _dataframe_ standard. 


<details>
<summary>
Premi√®res lignes des donn√©es
</summary>
```{r}
# 2) Regarder les premi√®res lignes
head(communes_borders)
```
</details>

3. Afficher le `crs` de `communes_borders`. Ce dernier contr√¥le la
transformation de l'espace tridimensionnel terrestre en une surface plane.
Utiliser `st_transform` pour transformer les donn√©es en Lambert 93, le 
syst√®me officiel (code EPSG 2154). 

```{r}
#| output: false

# 3) Afficher le crs
sf::st_crs(communes_borders)
```

4. Afficher les communes des Hauts de Seine (d√©partement 92) et repr√©senter rapidement la carte.

```{r}
#| label: plot-92
#| output: false

# 4) afficher les communes du d√©partement 92
hds <- communes_borders %>% filter(INSEE_DEP == "92")
map_92 <- ggplot(hds) +
    geom_sf(fill = "white") + theme_void()
```

5. Ne conserver que Paris et r√©pr√©senter les fronti√®res sur une carte : quel est le probl√®me pour
une analyse de Paris intramuros?

```{r}
paris_raw <- communes_borders %>% filter(INSEE_DEP == "75")
map_paris_raw <- ggplot(paris_raw) +
    geom_sf(fill = "white") + theme_void()
```

On remarque rapidement le probl√®me. 
On ne dispose ainsi pas des limites des arrondissements parisiens, ce
qui appauvrit grandement la carte de Paris. 

6. Cette fois, utiliser l'argument `borders="COMMUNE_ARRONDISSEMENT"` pour obtenir
un fonds de carte consolid√© des communes avec les arrondissements dans les grandes villes. 
Convertir en Lambert 93. 

```{r}
#| output: false
petite_couronne <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE_ARRONDISSEMENT",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022) %>%
  st_transform(2154)
petite_couronne_mercator <- petite_couronne %>%
  st_transform(4326)

map_paris_arrondissements <- ggplot(petite_couronne) +
    geom_sf(fill = "white") + theme_void()
```


:::


```{r}
#| output: false

# 3) Afficher le crs
sf::st_crs(communes_borders)
# Les donn√©es sont en WGS84, on les reprojette en lambert 93
communes_borders <- communes_borders %>% st_transform(2154)
```


<details>

<summary>
Si vous d√©sirez observer l'aspect de la
carte du 92 (question 4), d√©roulez cette partie.
</summary>

```{r}
map_92
```

</details>

<details>
<summary>
Carte de Paris attendue √† la question 5 et √† la question 6
</summary>

A la question 5, Paris intra-muros est bien pauvre: 

```{r}
# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?
map_paris_raw
```

A l'issue de la  question 6, on a bien une carte de la petite couronne avec
des arrondissements:

```{r}
# 6) Repr√©senter la carte de Paris avec arrondissements
map_paris_arrondissements
```


</details>

## Le syst√®me de projection

Un concept central dans les logiciels de GIS est la notion de syst√®me de
projection. L'exercice pr√©c√©dent imposait parfois certaines projections
sans expliquer l'importance de ces choix. {{< fa brands r-project >}}, comme
tout SIG, permet une gestion coh√©rente des projections. 

L'exercice suivant vise √† introduire aux principales
fonctionnalit√©s de {{< fa brands r-project >}}
√† ce propos. Il illustre les probl√®mes communs que peuvent rencontrer
les g√©ographes dans la gestion des syst√®mes de projection. 




::: {.callout-tip}
## Exercice 2: Les projections, repr√©sentations et approximations

Voici un code pour r√©cup√©rer les fronti√®res fran√ßaises (d√©coup√©es par r√©gion)

```{r}
#| output: false
#| echo: true
france <- download_vectorfile_url_all(
      values = "metropole",
      crs = 4326,
      borders = "REGION",
      vectorfile_format="geojson",
      filter_by="FRANCE_ENTIERE",
      source="EXPRESS-COG-CARTO-TERRITOIRE",
      year=2022)
```

1. S'amuser √† repr√©senter les limites de la France avec plusieurs projections:

- Mercator WGS84 (EPSG: 4326)
- Projection healpix (`+proj=healpix +lon_0=0 +a=1`)
- Projection pr√©vue pour Tahiti (EPSG: 3304)
- Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)

2. Utiliser la fonction `st_area` sur calculer la superficie en $km^2$
des r√©gions fran√ßaises dans les deux syst√®mes de projection suivants: 
WGS84 (EPSG: 4326) et Lambert 93 (EPSG: 2154). Calculer la diff√©rence en $km^2$
pour chaque r√©gion.
:::

```{r}
#| output: false
france_2154 <- france %>% sf::st_transform(2154)
france_healpix <- france %>% sf::st_transform("+proj=healpix +lon_0=0 +a=1")
france_5070 <- france %>% sf::st_transform(5070)
france_3304 <- france %>% sf::st_transform(3304)
```

Avec la question 1 illustrant quelques cas pathologiques,
on comprend que les projections ont un effet d√©formant
qui se voit bien lorsqu'on prend
quelques cas pathologiques:

```{r}
#| label: fig-effet-mercator
#| fig-cap: "Comparaison des projections"
#| fig-subcap: 
#|   - "Mercator WGS84 (EPSG: 4326)"
#|   - "Projection healpix (+proj=healpix +lon_0=0 +a=1)"
#|   - "Projection pr√©vue pour Tahiti (EPSG: 3304)"
#|   - "Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)"
#| layout-ncol: 2

ggplot(france) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_healpix) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_3304) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_5070) +
    geom_sf(fill = "white") + theme_void()
```

```{r}
mismatch_france <- france %>%
  mutate(superficie_4326 = set_units(st_area(.), "km^2")) %>%
  st_transform(2154) %>%
  mutate(superficie_2154 = set_units(st_area(.), "km^2")) %>%
  mutate(mismatch = superficie_2154-superficie_4326) %>%
  select(NOM, superficie_4326, superficie_2154, mismatch)
```

Cependant le probl√®me n'est pas que visuel, il est √©galement
num√©rique. Les calculs g√©om√©triques am√®nent √† des diff√©rences
assez notables selon le syst√®me de r√©f√©rence utilis√©.

<details>
<summary>
Voir le tableau des approximations pour chaque r√©gion
</summary>
```{r}
mismatch_france %>% arrange(desc(mismatch))
```
</details>

On peut repr√©senter ces approximations sur une carte[^notecarte] pour se faire
une id√©e des r√©gions o√π l'erreur de mesure est la plus importante.

[^notecarte]: Cette carte n'est pas trop soign√©e, c'est normal nous verrons comment
faire de belles cartes ult√©rieurement.

```{r}
#| label: fig-erreur-mesure
#| fig-cap: Approximations li√©es au syst√®me de projection WGS 84
ggplot(mismatch_france) +
  geom_sf(aes(fill = as.numeric(mismatch))) +
  scale_fill_gradient2() +
  labs(title = "Approximations li√©es √† la projection", fill = "km¬≤") +
  theme_void() + theme(legend.position = "bottom")
```

Ce type d'erreur de mesure est normal √† l'√©chelle du territoire fran√ßais. 
Les projections h√©rit√®res du Mercator d√©forment les distances,
surtout lorqu'on se rapproche de l'√©quateur ou des p√¥les. 

::: {#fig-mercator}

![Exemple de reprojection de pays depuis le site [thetruesize.com](https://www.thetruesize.com/)](https://pythonds.linogaliana.fr/content/manipulation/truesize.png){#fig-surus}

!["Don't trust the Mercator projection" sur `Reddit`](img/mercator.jpg){#fig-mercator-funny}

La projection Mercator, une vision d√©formante
:::



Il n'est donc pas suprenant que nos d√©formations soient exacerb√©es aux
extr√®mes du territoire m√©tropolitain. 
Si les approximations sont l√©g√®res sur de petits territoires,
les erreurs peuvent √™tre 
non n√©gligeables √† l'√©chelle de la France.

Il faut donc syst√©matiquement
repasser les donn√©es dans le syst√®me de projection Lambert 93 (le
syst√®me officiel pour la m√©tropole) avant d'effectuer des calculs g√©om√©triques.



## Utiliser des donn√©es g√©ographiques comme des couches graphiques


Souvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des
rep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter
un autre jeu de donn√©es.

On va partir des donn√©es de localisation des
stations velib, 
disponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et 
requ√™tables directement par l'url
<https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr>

```{r}
url <- "https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
```


Dans le prochain exercice, nous proposons de cr√©er rapidement une 
carte comprenant trois couches:

- Les localisations de stations sous forme de points ;
- Les bordures des communes et arrondissements pour contextualiser ;
- Les bordures des d√©partements en traits plus larges pour contextualiser √©galement. 

Nous irons plus loin dans le travail cartographique dans le prochain
chapitre. Mais √™tre en mesure de positionner rapidement
ses donn√©es sur une carte est
toujours utile dans un travail exploratoire. 

En amont de l'exercice,
utiliser la fonction suivante du _package_ `cartiflette` pour r√©cup√©rer
le fonds de carte des d√©partements de la petite couronne:

```{r}
#| echo: true
#| output: false
idf <- download_vectorfile_url_all(
      values = "11",
      crs = 4326,
      borders = "DEPARTEMENT",
      vectorfile_format="geojson",
      filter_by="REGION",
      source="EXPRESS-COG-CARTO-TERRITOIRE",
      year=2022)
petite_couronne_departements <- idf %>%
  filter(INSEE_DEP %in% c("75","92","93","94"))
```



::: {.callout-tip}
## Exercice 3: importer et explorer les donn√©es velib

On commence par r√©cup√©rer les donn√©es n√©cessaires √† la production
de cette carte.

1. En utilisant l'URL pr√©c√©dent, importer les donn√©es velib sous le nom `station`
2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces
derni√®res dans le m√™me syst√®me de projection que les stations de v√©lib
3. Ne conserver que les 50 principales stations (variable `capacity`)

On peut maintenant construire la carte de mani√®re s√©quentielle avec `ggplot`

4. En premier lieu, gr√¢ce √† `geom_sf`, 
repr√©senter exclusivement les positions des stations
et ajuster la taille en fonction de la variable `capacity`

5. Ajouter la couche des communes d'arrondissements et des communes
    + Comme ces limites administratives sont stock√©es dans un _dataframe_ diff√©rent, il va falloir utiliser l'argument `data`
    + Utiliser `fill = "transparent"` pour que l'int√©rieur du polygone ne masque pas nos points

6. Ajouter la couche des d√©partements

7. En supposant que votre objet `ggplot` s'appelle `carte`, vous pouvez
utiliser le code suivant pour am√©liorer rapidement l'esth√©tique

```r
carte +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(color = "none", size = guide_legend(title.position="top", title.hjust = 0.5)) +
  labs(size = "Capacit√© de la station", title = "Les 50 principales stations de v√©lib")
```


:::

```{r}
#| output: false
# 1. Importer les donn√©es velib
stations <- st_read(url)
```

```{r}
#| output: false
# 2. Reprojection
st_crs(stations)
stations <- stations %>% 
  st_transform(st_crs(petite_couronne))
```


```{r}
#| output: false
# 3. Principales stations
principales_stations <- stations %>%
  arrange(desc(capacity)) %>%
  head(50)
```


```{r}
# 4. Principales stations sous forme de nuage de points
carte <- ggplot(principales_stations) +
  geom_sf(aes(color = "red", size = capacity))
```

<details>
<summary>
Les stations plac√©es sur un plan, √† l'issue de la question 4
</summary>
```{r}
carte
```
</details>

```{r}
# Question 5
carte <- carte + geom_sf(data = petite_couronne, fill = "transparent")
```

<details>
<summary>
Ajout d'une couche d'arrondissements (question 5)
</summary>

```{r}
carte
```
</details>

```{r}
# Question 6
carte <- carte +
  geom_sf(data = petite_couronne_departements, fill = "transparent", color = "blue")
```

<details>
<summary>
Ajout de la couche des d√©partements (question 6)
</summary>

```{r}
carte
```

</details>

La carte finalis√©e (question 7), obtenue gr√¢ce √† une demi-douzaine de lignes
de code seulement, est ainsi:

```{r}
# Question 7
carte +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(color = "none", size = guide_legend(title.position="top", title.hjust = 0.5)) +
  labs(size = "Capacit√© de la station", title = "Les 50 principales stations de v√©lib")
```




## Jointures spatiales

Les jointures attributaires fonctionnent comme avec un `tibble` classique.
Pour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `sf`.
En revanche, l'un des int√©r√™ts des objets `sf` est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† plusieurs fonctions. Les jointures les plus communes sont:

| Fonction |	Op√©ration |
|----------|------------|
|`st_intersects()` | 	Quelles g√©om√©tries de x intersectent celles de y ? |
|`st_contains()` | 	Quelles g√©om√©tries de x contiennent celles de y ? |
|`st_disjoint()` | 	Quelles g√©om√©tries de x sont disjointes √† celles de y ? |
|`st_is_within_distance()` | 	Quelles g√©om√©tries de x est √† moins de m/km de celles de y ? |

La documentation √† laquelle se
r√©f√©rer est [ici](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn03_join_filter.html). 
Une version p√©dagogique se trouve dans la documentation [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_spatiales#joindre-des-donn%C3%A9es-g%C3%A9ographiques-et-attributaires). 


::: {.callout-tip}
## Exercice 4: Associer les stations aux communes et arrondissements auxquels elles appartiennent

Dans cet exercice, on va supposer que :

- les localisations des stations `velib` 
sont stock√©es dans un _dataframe_ nomm√© `stations`
- les donn√©es administratives
sont dans un _dataframe_ nomm√© `petite_couronne`.

1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `petite_couronne`. Appeler cet objet `stations_info`
2. Cr√©er les objets `stations_19e` et `arrondissement_19e` pour stocker, respectivement, 
les stations appartenant au 19e et les limites de l'arrondissement
2. Repr√©senter la carte des stations du 19e arrondissement (s'aider de la variable `NOM`)
    + Ne repr√©senter sur la carte que les stations du 19e avec des points bleus
    + Repr√©senter en rouge les limites du 19e
    + Vous pouvez mettre en fond de carte tous les arrondissements parisiens pour contextualiser. 
3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune. Repr√©senter sur une carte chacune des informations
4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)
5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)

:::

```{r}
stations_info <- st_join(stations, petite_couronne, join = st_within)
```

```{r}
stations_19e <- stations_info %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)
arrondissement_19e <- petite_couronne %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)
```


```{r}
ggplot(petite_couronne %>% filter(INSEE_DEP == 75)) +
  geom_sf(aes(fill = grepl("19e", NOM)), alpha = 0.1) +
  geom_sf(data = stations_19e) +
  scale_fill_viridis_d() +
  theme_void() +
  theme(legend.position = "none")
```


```{r}
pal_fun <- colorQuantile("YlOrRd", NULL, n = 4)

leaflet(stations_19e) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    radius = ~sqrt(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5) %>%
  addPolylines(data = arrondissement_19e)
```

```{r}
#| eval: false
# Question 3
stations_agg <- stations_info %>%
  group_by(NOM) %>%
  mutate(stationcode_count = n_distinct(stationcode),
            capacity_sum = sum(capacity)) %>%
  st_drop_geometry()

data_paris <- petite_couronne %>%
  mutate(area = units::set_units(st_area(.), "km^2"))
df <- petite_couronne %>% left_join(stations_agg)
```

Enfin, dans la question 4,
si on repr√©sente plut√¥t la capacit√© 
sous forme de densit√©, pour tenir compte
de la taille diff√©rente des arrondissements,
on obtient cette carte:

```{r}
#| eval: false
df %>% mutate(capacity_density = capacity/area)
```




## Exercices suppl√©mentaires

```{r}
#| eval: false
library(leaflet)

pal_fun <- colorQuantile("YlOrRd", NULL, n = 4)
principales_stations_wgs84 <- principales_stations %>%
  st_transform(4326)

leaflet(principales_stations_wgs84) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5)
```

