---
title: "Manipuler des donn√©es spatiales avec `sf`"
echo: false
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=true&init.personalInit=¬´https%3A%2F%2Fraw.githubusercontent.com%2Flinogaliana%2Fr-geographie%2Fmain%2Fsspcloud%2Finit.sh¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
D√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/wrangling.qmd)
pour afficher les slides en plein √©cran.
</summary>


``` {.yaml code-preview="/slides/wrangling.qmd"}
```

</details>


Dans ce TP,
nous allons apprendre √† importer et
manipuler des donn√©es spatiales avec
{{< fa brands r-project >}}.

Ce logiciel propose
des fonctionnalit√©s tr√®s int√©ressantes pour ce type de
donn√©es complexes qui le rendent capable de se comporter
comme un SIG. Gr√¢ce √† la librairie [`sf`](https://r-spatial.github.io/sf/), une extension
de `dplyr` aux donn√©es spatiales, les
donn√©es g√©ographiques pourront √™tre manipul√©es
comme n'importe quel type de donn√©es avec {{< fa brands r-project >}}.
La complexit√© induite par la dimension spatiale ne sera pas ressentie. 

<details>
<summary>
`sf`, une association de tables de donn√©es classiques √† des g√©om√©tries
</summary>
![](https://user-images.githubusercontent.com/520851/50280460-e35c1880-044c-11e9-9ed7-cc46754e49db.jpg){width="70%"}
</details>

Si vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},
une version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_TP.html).


```{r}
#| eval: false
remotes::install_github("linogaliana/cartiflette-r")
install.packages("leaflet")
```

Dans ce chapitre, nous allons utiliser les packages
suivants:


```{r}
#| echo: true
#| output: false
library(units)
library(dplyr)
library(sf)
library(ggplot2)
library(leaflet)
library(cartiflette)
```


::: {.callout-note collapse="true"}
## Note sur les annotations

Certains exemples de code pr√©sentent des annotations sur le c√¥t√©,
passez votre souris dessus pour les afficher, comme ci-dessous

```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. Je m'affiche quand on passe la souris sur moi üê≠ !

:::


## D√©couverte des objets g√©ographiques 

Dans cette partie,
nous utiliserons
les fonds de carte de l'IGN dont
la mise √† disposition est facilit√©e
par le projet [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)[^cartiflette-r].

[^cartiflette-r]:
  La librairie {{< fa brands r-project >}} est exp√©rimentale mais 
  les prochaines semaines devraient permettre de combler ce manque. 
  Une documentation interactive illustrant le code n√©cessaire pour reproduire
  telle ou telle carte est disponible sur [linogaliana.github.io/cartiflette-website](https://linogaliana.github.io/cartiflette-website/index.html).


::: {.callout-tip}
## Exercice 1: d√©couverte des objets g√©ographiques

En premier lieu, on r√©cup√®re des donn√©es g√©ographiques gr√¢ce
au _package_ `cartiflette`.

1. S'inspirer des exemples de code pr√©sents dans les slides mobilisant
le package `cartiflette`
pour t√©l√©charger les donn√©es communales (produit `Admin Express` de l'IGN)
des d√©partements de la petite couronne (75, 92, 93 et 94). L'argument √† utiliser
dans cet exercice est `borders="COMMUNE"`
Vous pouvez nommer l'objet `communes_borders`.

```{r}
#| output: false
#| label: download-borders-communes
# 1. Chargement des donn√©es de cartiflette
communes_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec
un _dataframe_ standard. 


<details>
<summary>
Premi√®res lignes des donn√©es
</summary>
```{r}
# 2) Regarder les premi√®res lignes
head(communes_borders)
```
</details>

3. Afficher le `crs` de `communes_borders`. Ce dernier contr√¥le la
transformation de l'espace tridimensionnel terrestre en une surface plane.
Utiliser `st_transform` pour transformer les donn√©es en Lambert 93, le 
syst√®me officiel (code EPSG 2154). 

```{r}
#| output: false

# 3) Afficher le crs
sf::st_crs(communes_borders)
```

4. Afficher les communes des Hauts de Seine (d√©partement 92) et repr√©senter rapidement la carte.

```{r}
#| label: plot-92
#| output: false

# 4) afficher les communes du d√©partement 92
hds <- communes_borders %>% filter(INSEE_DEP == "92")
map_92 <- ggplot(hds) +
    geom_sf(fill = "white") + theme_void()
```

5. Ne conserver que Paris et r√©pr√©senter les fronti√®res sur une carte : quel est le probl√®me pour
une analyse de Paris intramuros?

```{r}
paris_raw <- communes_borders %>% filter(INSEE_DEP == "75")
map_paris_raw <- ggplot(paris_raw) +
    geom_sf(fill = "white") + theme_void()
```

On remarque rapidement le probl√®me. 
On ne dispose ainsi pas des limites des arrondissements parisiens, ce
qui appauvrit grandement la carte de Paris. 

6. Cette fois, utiliser l'argument `borders="COMMUNE_ARRONDISSEMENT"` pour obtenir
un fonds de carte consolid√© des communes avec les arrondissements dans les grandes villes. 
Convertir en Lambert 93. 

```{r}
#| output: false
petite_couronne <- download_vectorfile_url_all(
    crs = 4326,
    values = c("75", "92", "93", "94"),
    borders="COMMUNE_ARRONDISSEMENT",
    vectorfile_format="geojson",
    filter_by="DEPARTEMENT",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022) %>%
  st_transform(2154)
petite_couronne_mercator <- petite_couronne %>%
  st_transform(4326)

map_paris_arrondissements <- ggplot(petite_couronne) +
    geom_sf(fill = "white") + theme_void()
```


:::


```{r}
#| output: false

# 3) Afficher le crs
sf::st_crs(communes_borders)
# Les donn√©es sont en WGS84, on les reprojette en lambert 93
communes_borders <- communes_borders %>% st_transform(2154)
```


<details>

<summary>
Si vous d√©sirez observer l'aspect de la
carte du 92 (question 4), d√©roulez cette partie.
</summary>

```{r}
map_92
```

</details>

<details>
<summary>
Carte de Paris attendue √† la question 5 et √† la question 6
</summary>

A la question 5, Paris intra-muros est bien pauvre: 

```{r}
# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?
map_paris_raw
```

A l'issue de la  question 6, on a bien une carte de la petite couronne avec
des arrondissements:

```{r}
# 6) Repr√©senter la carte de Paris avec arrondissements
map_paris_arrondissements
```


</details>


::: {.callout-tip}
## Exercice 2: Les projections, repr√©sentations et approximations

Voici un code pour r√©cup√©rer les fronti√®res fran√ßaises (d√©coup√©es par r√©gion)

```{r}
#| output: false
#| echo: true
france <- download_vectorfile_url_all(
      values = "metropole",
      crs = 4326,
      borders = "REGION",
      vectorfile_format="geojson",
      filter_by="FRANCE_ENTIERE",
      source="EXPRESS-COG-CARTO-TERRITOIRE",
      year=2022)
```

1. S'amuser √† repr√©senter les limites de la France avec plusieurs projections:

- Mercator WGS84 (EPSG: 4326)
- Projection healpix (+proj=healpix +lon_0=0 +a=1)
- Projection pr√©vue pour Tahiti (EPSG: 3304)
- Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)

2. Utiliser la fonction `st_area` sur calculer la superficie en $km^2$
des r√©gions fran√ßaises dans les deux syst√®mes de projection suivants: 
WGS84 (EPSG: 4326) et Lambert 93 (EPSG: 2154). Calculer la diff√©rence en $km^2$
pour chaque r√©gion.
:::

```{r}
#| output: false
france_2154 <- france %>% sf::st_transform(2154)
france_healpix <- france %>% sf::st_transform("+proj=healpix +lon_0=0 +a=1")
france_5070 <- france %>% sf::st_transform(5070)
france_3304 <- france %>% sf::st_transform(3304)
```

Les projections ont ainsi un effet d√©formant qui se voit bien lorsqu'on prend
quelques cas pathologiques:

```{r}
#| label: fig-effet-mercator
#| fig-cap: "Comparaison des projections"
#| fig-subcap: 
#|   - "Mercator WGS84 (EPSG: 4326)"
#|   - "Projection healpix (+proj=healpix +lon_0=0 +a=1)"
#|   - "Projection pr√©vue pour Tahiti (EPSG: 3304)"
#|   - "Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)"
#| layout-ncol: 2

ggplot(france) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_healpix) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_3304) +
    geom_sf(fill = "white") + theme_void()

ggplot(france_5070) +
    geom_sf(fill = "white") + theme_void()
```

```{r}
mismatch_france <- france %>%
  mutate(superficie_4326 = set_units(st_area(.), "km^2")) %>%
  st_transform(2154) %>%
  mutate(superficie_2154 = set_units(st_area(.), "km^2")) %>%
  mutate(mismatch = superficie_2154-superficie_4326) %>%
  select(NOM, superficie_4326, superficie_2154, mismatch)
```

Les approximations sont non n√©gligeables: 

```{r}
mismatch_france %>% arrange(desc(mismatch))
```

On peut repr√©senter celles-ci sur une carte pour se faire
une id√©e des r√©gions o√π l'erreur de mesure est la plus importante

```{r}
#| label: fig-erreur-mesure
ggplot(mismatch_france) +
  geom_sf(aes(fill = as.numeric(mismatch))) +
  scale_fill_gradient2() +
  labs(title = "Approximations li√©es √† la projection (km¬≤)", fill = NULL) +
  theme_void() + theme(legend.position = "bottom")
```

Ce type d'erreur de mesure est normal √† l'√©chelle du territoire fran√ßais. 
Les projections h√©rit√®res du Mercator d√©forment les distances. Si cela ne se
voit pas forc√©ment sur de petits territoires, les erreurs peuvent √™tre 
non n√©gligeables √† l'√©chelle de la France.

Il faut donc repasser les donn√©es dans le syst√®me de projection Lambert 93 (le
syst√®me officiel pour la m√©tropole) avant d'effectuer des calculs g√©om√©triques.



## Utiliser des donn√©es g√©ographiques comme des couches graphiques


Souvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des
rep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter
un autre jeu de donn√©es.

On va partir des donn√©es de localisation des
stations velib, 
disponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et 
requ√™tables directement par l'url
<https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr>

```{r}
url <- "https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr"
```

::: {.callout-tip}
## Exercice 3: importer et explorer les donn√©es velib

1. Importer les donn√©es velib sous le nom `station`
2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces
derni√®res dans le m√™me syst√®me de projection que les stations de v√©lib
3.  Repr√©senter sur une carte les 50 stations les plus importantes (variable `capacity`). Vous pouvez √©galement afficher le fonds de carte des arrondissements de Paris.
Cette [page](https://geopandas.org/mapping.html#maps-with-layers) peut vous aider pour comprendre comment afficher plusieurs couches √† la fois. Vous pouvez customiser la carte en retirant les axes gr√¢ce √† la m√©thode `set_axis_off` et mettre un titre tel que _"Les 50 principales stations de V√©lib"_ avec la m√©thode `set_title`. 
4. Afficher √©galement (trait bleu et √©pais) les r√©seaux de transport en communs, disponibles [ici](https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/map/?location=7,48.69717,2.33167&basemap=jawg.streets). L'url √† requ√™ter est
<https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr>
:::



```{r}
#| output: false
# 1) Importer les donn√©es velib
stations <- st_read(url)
```

```{r}
head(stations)
```


```{r}
# 2) Reprojection
st_crs(stations)
stations <- stations %>% 
  st_transform(st_crs(communes_borders))
```

La carte attendu √† l'issue de la question 3 a l'aspect suivant:


```{r}
# 3) Carte des 50 stations les plus importantes. 

paris <- communes_borders %>%
  filter(INSEE_DEP == "75")

principales_stations <- stations %>%
  arrange(desc(capacity)) %>%
  head(50)

ggplot(paris) +
  geom_sf(fill = "white") + geom_sf(data = principales_stations) + 
  theme_void()
```


```{r}
# 4) R√©seaux de transport en communs
url <- "https://data.iledefrance-mobilites.fr/explore/dataset/traces-du-reseau-ferre-idf/download/?format=geojson&timezone=Europe/Berlin&lang=fr"

transports <- st_read(url) %>%
  st_transform(2154)
```

L'ajout du r√©seau de m√©tro permet d'obtenir une carte ressemblant √† celle-ci:


```{r}
metro <- transports %>% filter(mode == "METRO")

ggplot(paris) +
  geom_sf(fill = "white") + geom_sf(data = principales_stations, color = "red") + 
  geom_sf(data = metro, color = "royalblue", alpha = 0.4) +
  theme_void()
```

Pour faire une belle carte, il faudrait couper les lignes de m√©tro
via une jointure spatiale ou privil√©gier
un fonds de carte conceptuel. 
La m√©thode pour faire des cartes contextuelles
est propos√©e en [exercice suppl√©mentaire üëáÔ∏è](#exo-supp).
puisqu'elle implique des connaissances minimales avec `leaflet`
que nous verrons ult√©rieurement.

## Jointures spatiales

Les jointures attributaires fonctionnent comme avec un `tibble` classique.
Pour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `sf`.
En revanche, l'un des int√©r√™ts des objets geopandas est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† plusieurs fonctions:

| Fonction |	Op√©ration |
|----------|------------|
|`st_intersects()` | 	Quelles g√©om√©tries de x intersectent celles de y ? |
|`st_contains()` | 	Quelles g√©om√©tries de x contiennent celles de y ? |
|`st_disjoint()` | 	Quelles g√©om√©tries de x sont disjointes √† celles de y ? |
|`st_is_within_distance()` | 	Quelles g√©om√©tries de x est √† moins de 
m/km de celles de y ? |

La documentation √† laquelle se
r√©f√©rer est [ici](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn03_join_filter.html). 
Une version p√©dagogique se trouve dans la documentation [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_spatiales#joindre-des-donn%C3%A9es-g%C3%A9ographiques-et-attributaires). 


::: {.callout-tip}
## Exercice 4: Associer les stations aux communes et arrondissements auxquels elles appartiennent

1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `data_paris`. Appeler cet objet `stations_info`
2. Repr√©senter la carte des stations du 19e arrondissement (s'aider de la variable `NOM`). Vous pouvez mettre en fond de carte les arrondissements parisiens. 
3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune (pour vous aider, vous pouvez compl√©ter vos connaissances avec [ce tutoriel](https://pandas.pydata.org/docs/getting_started/intro_tutorials/06_calculate_statistics.html)). Repr√©senter sur une carte chacune des informations
4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)
5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)

:::

```{r}
stations_info <- st_join(stations, data_paris, join = st_within)
```

Pour la question 2,
la premi√®re m√©thode consiste √† afficher
toute la ville mais √† ne repr√©senter que
les points des stations du 19e:

```{r}
stations_19e <- stations_info %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)
arrondissement_19e <- communes_borders %>%
  filter(grepl("19e", NOM)) %>%
  st_transform(4326)

pal_fun <- colorQuantile("YlOrRd", NULL, n = 4)

leaflet(stations_19e) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    radius = ~sqrt(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5) %>%
  addPolylines(data = arrondissement_19e)
```

```{r}
# Question 3
stations_agg <- stations_info %>%
  group_by(NOM) %>%
  mutate(stationcode_count = n_distinct(stationcode),
            capacity_sum = sum(capacity)) %>%
  st_drop_geometry()

communes_borders <- communes_borders %>%
  mutate(area = units::set_units(st_area(.), "km^2"))
df <- communes_borders %>% left_join(stations_agg)
```

Enfin, dans la question 4,
si on repr√©sente plut√¥t la capacit√© 
sous forme de densit√©, pour tenir compte
de la taille diff√©rente des arrondissements,
on obtient cette carte:

```{r}
df %>% mutate(capacity_density = capacity/area)
```




## Exercices suppl√©mentaires

```{r}
library(leaflet)

pal_fun <- colorQuantile("YlOrRd", NULL, n = 4)
principales_stations_wgs84 <- principales_stations %>%
  st_transform(4326)

leaflet(principales_stations_wgs84) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~pal_fun(capacity),
    popup = ~paste0(name, ": ", capacity, " places disponibles"),
    stroke = FALSE,
    fillOpacity = 0.5)
```

